Anne van Ede  3:48  
Hi Hello.

Michele Caini  4:05  
Hi, nice to meet you.

Anne van Ede  4:11  
Nice to meet you too. Well, before we start, I have to do like an introduction, officially. 

Michele Caini  4:37  
Yeah. 

Anne van Ede  4:38  
And so thank you for taking the time. By the way, that's the most important thing. Like I explained in my email, I do research on going from object oriented to data oriented, and more specifically to component based and I got interested in this too. years ago, when I found unity ECS. At that time still, and I got really excited like this is super cool. But I also noticed that a lot of other programmers were like hesitant to go from object oriented, which is what is taught at our university only, yeah, you don't get data oriented at all. So they were hesitant, and then the companies they work at are also hesitant because the programmers don't know it and then going from one to the other is very difficult. So I want to create a tool that helps with that in two ways, one in creating a design, not porting the entire code, but creating a design for a new structure, but also in educating the developers like, why is this design good. But for that, I need a good design. And that's very important, because I only got started like two years ago, next to my studies. So I need you guys to tell me what a good design is.  Basically, yes, 

Michele Caini  6:06  
Yes. You're still studying, right? You're still studying at the University.

Anne van Ede  6:12  
Yes, I'm still at the University. So you guys have the experience, not me.

Michele Caini  6:20  
Not that much.

Anne van Ede  6:22  
Anyway, the interview will be open questions, and I tried to make the questions as general as possible, while still specific enough to get stuff. So if there's a question that doesn't suit your situation, then just tell me so or answer some more different to your situation? If you a remark that is similar to the question I asked, but not, then please say immediately, but if it's very different than wait until the end, then I can, like, kind of structure it. The same for questions you might have. We planned about an hour, but would it be a problem if we run a little long?

Michele Caini  7:03  
No, no, no, it's fine.

Anne van Ede  7:05  
Then I don't have to mind that. Yeah, I officially need to ask this. For my thesis will be publicized. I don't know how far, but would it be alright, if I, you know, use your name, then I, you know, they don't know that I called my next door neighbor or something. 

Michele Caini  7:24  
It's fine. 

Anne van Ede  7:25  
In the same way. I would like to record this video so I can type it out later strictly for that.

Michele Caini  7:32  
Okay, okay. Yeah, okay. Yeah, okay. Okay. You record my horrible English, but it's fine. Just don't spread the word on the on the social network.

Anne van Ede  7:42  
no, no, no, then I can just type it out easier. That's, it will be a pain to do that right now.

Michele Caini  7:49  
Okay. Nice, finally, because I work with companies abroad, but I don't I'm not very good at speaking English. So I'm always a little embarrassing. Anyway.

Anne van Ede  8:03  
That's okay. If I if I don't understand you, I'll just ask you again.

Michele Caini  8:08  
Yeah, sure.

Anne van Ede  8:10  
That's it for my side. Are there any questions you have for me, before we get started?

Michele Caini  8:16  
No you have been pretty clear and probably they come up during our discussion. So I do them while we discuss and as they as they arrive in my mind, okay. 

Anne van Ede  8:28  
Okay. 

Michele Caini  8:30  
Good.

Anne van Ede  8:37  
So I have some like you, you saw the example questions that I sent you. Those are mostly the topics that I will ask about, and then I will ask like specific questions in it. But the first is, just to get started. Can you tell me how you first got started with ECS?

Michele Caini  8:54  
Can I ask you to raise a little the microphone? The audio of the microphone because I might have you at the top? I still have you a little low.

Anne van Ede  9:08  
I will.

Michele Caini  9:10  
Yeah, if it's not a problem.

Anne van Ede  9:15  
I have this slider here, but it doesn't do anything. Okay. Oh, wait, there it is.

Michele Caini  9:22  
Okay, yeah, that's Yeah, definitely. 

Anne van Ede  9:25  
Okay. Do I need to repeat the question?

Michele Caini  9:30  
Yes, yes, please.

Anne van Ede  9:31  
Um, can you tell me how you first got started with ECS?

Michele Caini  9:36  
I started with ECS because of the game I was working on. And the game has nothing to do with ECS. And that definitely didn't have performance requirements. But I was so intrigued by this model, and we started doing this small game with another library, it's called Entityx. You know it, right. All of a sudden, I see. Okay, I think we can do better. Because the design of this library, I didn't like very much the design of the library. It has some interesting features, but also some others that are a little strange, or at least I had, that they didn't feel with my mental patterns. And so I decided to implement my own solution and experiment with something new. So I started looking around for some data structure, that could fit the purpose. And I find another interesting library from an Italian guy is called Vittorio Romeo, and the library is ECST. Like that, you know?

Anne van Ede  11:00  
I don't know what that one.

Michele Caini  11:02  
Yeah. He also wrote it a this library. It is his bachelor degrees work or something like that. So it's interesting. Maybe you can find also his thesis online? Let me share the screen. I don't even know. Yeah, this one. Okay. Okay, this one? In here, you can also find the component is this it? 

Anne van Ede  11:38  
Yes, I think so. 

Michele Caini  11:39  
Maybe there is a lot of material here for you. He is from Italy, but he works in London, something like that. I don't remember. And he is very, very skilled at some. And this one is something similar to ENTT. Is this part sets? Did I guess, you know, yeah, how they work. However, they use this part set on the system side. So every system is a sparse set. And there is a sort of central repository like the registry of ENTT that updates the sparse sets of the system and can store the components the way you like internally. So it's kind of little odd, it's kind of the opposite design, if you compare it with ENTT. But it was interesting, I like it a lot the idea of sparse sets and therefore I decided to try to implement my own solution. And that's it, it was an ENTT. So I published it, I published the game, the game was pretty stupid, but we wanted to try the library for emotional recognition, so when you smile and things like that, and the game was about like there was a lot of images that pop up from all around the screen and you should try to smile to crush them or to make, it was pretty fun to play. And anyway, we decided to the game was in this store, is no longer there because we have to pay there this library so we decided to remove it from the store. When we remove the game, we decided to publish the, I decided to publish the library I wrote for this game in I had also other stuff I wrote for other purposes. So for work and for others, private projects, things like that. So initially, there was only the ECS part. Then I added a serial part and so on then, after a few months, a company from the USA is called Neil for autonomous driving car contacted me because they were interested in after a few other months. I was in Stockholm, for more Mojang. From there. I didn't expect to get traction with this library. Honestly, it was like an experimental library at all. It was 2017. My son was one years old. And it was my relaxing activity after dinner when the son was sleeping. So it was how ENTT started?

Anne van Ede  14:37  
Nice. Well, you already said that. You already discussed it a little but can you tell me how you currently use ECS?

Michele Caini  14:49  
Well, not much, at least. Currently, I'm working with Microsoft Mojang Studios and they use ECS Minecraft I obviously can't tell anything about about it, because it's covered by an NDA, they may put me in jail. I use it also for a smaller game I'm working with, with a friend of mine. I am giving a client c++ class to sort of private school in Italy, the school IVA, Italian video game Academy and the c++ class is also about performance. And therefore we write a game with ECS. Usually we use ENTTor Entityx, because Entityx is a little easier to understand for for newcomers, so I often use it and rather than ENTT. So this all these are about games, but it will also use ECS out of games. So my very first experience even before writing ENTT, was in 2016. I was reading the book from, wait a moment, I remember the name, Game Programming Patterns. Yeah, from I don't remember the name, Bob Nystrom. I was reading that book. And it has a chapter about component based design. Yeah, so I decided to experiment a little with a with a project I was working on for a company, it was about Cloud Storage. So the idea was to have a lot of small ARM boards, all connected together and to create a sort of swarm of boards to store inside files, and so on for the user. So that is pretty, how to say, it's pretty reliable. Because if a board dies, you have another 700 boards that can do the job for you. And we decided to experiment with a component based design. So that was my very first experiment. And probably also the only one I made out of the game sector. The game field actually. It was really interesting. It's more about component design without a proper loop. So it was on request system where random request, so when a when a user request arrives, you get this sort of pipeline with a bunch of system around them on these elements and the components when, but it fits pretty well. So that was my very first experience. Anyway, right here right now I'm using it only for for game programming, and mainly in Minecraft and a few other companies with which I'm, I'm working. But of course, I can tell much about the actual uses.

Anne van Ede  18:25  
Yeah, right. So you already mentioned a few, but can you name the ECS implementations that you've worked with? So obviously, ENTT, and Entityx you already mehtioned and ECST? But are there any others that you also use?

Michele Caini  18:43  
Yeah, there are many others. They they explored. I wouldn't say use. The most interesting ones are the three about which I also wrote some post, some articles. This is the one of Entityx, is very straightforward and easy to implement, easy to use, and it was pretty fine for small games. I like it, because it's also very, very easy to to explain things, to explain how things work, cause something like ENTT or the Unity ECS, are pretty complex. So you have to explain what ECS is and how it works and how it is implemented in a library and people usually don't understand very, very well what we're talking about. On the other side, the model of Entityx is very, very good for explaining things. So if you have to convince someone, it's probably, at least from my point of view, the right choice to introduce the topic. Because if you can represent the model of Entityx as a matrix and therefore you have this clear representation of how things work. In the other model I like is of course the one of ENTT because it's the one I like more because of some features it has. And that fits very well with a with how I usually like to code and the other one interesting is that of Unity. Even to be honest, I don't like it very much in the the way Unity implemented it because it has this, how to say it, this annoying problems when you add or remove. I used to add remove components very, very frequently to use the ECS model for delivering messages between Systems and between subsystems of the application, so I don't like very much the way he manages the arranges the memory because he has to copy things all over between tables. I like the model of Svelto.ECS. You know it right?

Anne van Ede  21:18  
Yes, yeah. Yeah. Yeah.

Michele Caini  21:23  
Yeah, it's kind of the sort of Unity model, but without the possibility of adding or removing components. So you get rid completely of the of the problem of moving things between tables because you define in advance on the archetypes also the kind of Entities you were going to use in your application. And then you can't really add components at runtime. So when you create an Entity is stored in a table and  there until it dies. I like it, I don't like to use it. Because as I said, I like more to how to remove components very frequently. But I find the more interesting and probably easier to use and less error prone than the model of Unity. It's kind of the model of Unity without some features, not very different at the end of the day. 

Anne van Ede  22:31  
Okay. Can you tell me in one or two sentences, so very short, the biggest advantage you see of ECS?

Michele Caini  22:43  
For me, it's flexibility. So it favours code refactoring, it favours adding new features to, also experiment with. So to see if a feature is, is working, and it's very, very flexible, it's not a matter of performance, usually. The performance important with this kind of tool when you are working with I don't know The Last of Us, or games like that, you don't really matter that, performance don't really matter. For the kind of games I'm working on. Even even Minecraft doesn't have this performance requirements. So it's more a matter of flexibility. So adding new fish or adding new components and testing refactoring and so on.

Anne van Ede  23:37  
Yeah. Now the other question. Yeah, in the same way, can you tell me very shortly, the biggest disadvantage of ECS that you see?

Michele Caini  23:49  
It's very, very difficult for some people. So it's not something that everybody can can use. It's like, I don't know functional programming. If you take developers, everybody can understand imperative programming, or common languages like, I don't know, C or C++. But functional programming is something that nobody can really understand. 

Anne van Ede  24:20  
I had to do a course, so I had to know, I know the basics, but it was a living hell, I understand what you mean.

Michele Caini  24:29  
Yes, ECS has exactly the same problem. It's something that has a lot of advantages, but also something that not all people can can work with and can use proficiently. So it's not something very, very easy to introduce in a team and you need to, to educate people and to teach them how to use things and because it's not that obvious. Also because University teaches object oriented programming and things like that. They're not very focused on performance or component based design.

Anne van Ede  25:06  
Yeah. Okay, so the next questions are designed in a few ways. First, we talk about the design process of ECS as a whole. So the overview, and then I'm going to ask something more about component design, specifically, because that's what my research will focus on. So, keep in mind that this even things that are so obvious for you, that you, you normally wouldn't say them just say it all, because yeah, I did my best making these questions, but like I said,

Michele Caini  25:50  
Yes, feel free to stop me if something isn't that obvious, and I just jump over it and go, don't worry, feel free to stop me at any time.

Anne van Ede  26:00  
Um, right. So, this is these questions are more for my tool as a whole. So, I'm trying to follow steps to create a ECS design and I have some ideas because I use Unity ECS. I know the steps that I would take there. So, these are more if you are making an ECS design, either for a new game or if you're converting a game or whatever, can you walk me through the steps you take to make a design?

Michele Caini  26:35  
With ECS design, you mean application wise are they have this specific part? So how I would design the ECS, I don't know, sub module to offer something to use and the rest of the game 

Anne van Ede  26:50  
Yes. So the the literally the components and the systems and how they work together with the entities and the rest of the game. So, specifically, indeed the ECS part the subsystem

Michele Caini  27:03  
Usually, when I try to explain how to move from a OOP designed to an ECS design, I usually suggest to put all the concept you have in mind, so, the the actors of your game not only characters, also non playing characters and player characters and all the objects you have in your games, try to put them one after the other in a rwo. Try to imagine how they are composed, how would you split them in sub parts. So for example, you have a player characters you can see within it the part that is about, I don't know, managing the input from the user, a part that is about rendering, a part it is about I don't know, moving so physics and so on and all the other parts.  My suggestion, when I also when I try to explain these in my classes, and to newcomers, is try to put everything in a row and to split every element in parts and you see that they usually overlaps, a lot of common parts, there is a lot of overlapping parts because this is also where using an ECS makes sense when you have a lot of objects a lot of different elements and they overlap for large parts. Okay, otherwise, it wouldn't make sense because if they didn't overlap, you would have a lot of or at least you have a component for every element. This is more or less also the process I I follow when I start something new. I try to define what I really use in my game or my application and try to focus on what parts compose the single element and when I find other parts that compose a single element for all my objects in the game more or less I have the first split of the more object oriented design. So that is how we usually think, you know I like to work with components based design but I am a human being and I'm still thinking like a human being. And this is a first split of my components and from that I start designing the usually systems. Consider the first split doesn't really consider, I don't know, gameplay feature so something like a bomb that explodes sometimes isn't part of this process is something I can add later so these are gameplay feature it's something that you can add at any time and are pretty easy to add because you define a new component usually the very often one component one one system gameplay feature. At this low level you have, I start with something like one component, one system and then try to see if I can splitmore I try to find the pitfalls. So for example, if I see that I need some data from a component also in another component and then I split this single element into sub components and I find that some system uses more than one component but usually I try to start from the one component one system model and go deeper deeper to see where I need more granularity. Because extreme granularity has the opposite problem. It is the problem with component based design is that if you have 1000 components that becomes yeah it's very flexible but it's very hard to work with so you have to find the right balance and usually I like to start from one component one system and go we with higher granularity only if needed and when needed. So to avoid problems and to have some because I also want to release something.

Anne van Ede  31:45  
Yeah, I do have a question. First you said that you put all the objects as they were next to each other and then find what overlaps and you say you make a first split but then you said that you used one component one system so do you mean one component one system literally so like literally one component or because you said it first you split it and then you have one component so I don't understand where that like what do you mean with that?

Michele Caini  32:17  
Yeah Yeah, sure. Let me try to find a, because I have some slides that should clarify what I'm saying but

Anne van Ede  32:35  
Wait do you mean that you first split it and then for every component you do you have at that moment because you split it at domain level, like rendering some something then you have one system for rendering and then you figure out if you need to split it more.

Michele Caini  32:51  
Yeah, can I share the screen so that I can. I can't share the screen you must allow me to do that.

Anne van Ede  33:08  
Oh great. I found it. Yeah, you should be able to share it now.

Michele Caini  33:15  
Yeah fine. So okay, here it is. So imagine I put them in a row, these elements okay. You see the screen? Yeah. Okay. So, here is a small example for the students of the c++ class, but it should clarify your task. I put in a row the hero, the orc, the wolf, the mountain and so on and I try to understand what components compose this type. So the hero has an input receiver, of course here I wrote already the components but I try to find what would be the sub models in an object oriented model or what would be the item or the features that they can share with others or that are unique for a single type. So for example, hero has a unique feature that is they receive inputs and it has something that shares with others that is there a movement component is reading position velocity by the movement component and it has some another feature that is shared with the other times, the sprite and so on. Okay, then I find all the parts that compose the hero, then I do the same with the orc, the wolf and the mountain. I dont usually have these types here, it is just player character and another player character not the orc, the wolf and the mouse, because I don't even know what I it is. It see it's hard to say. And then I have a bunch of, let's say components, a unique features that are either unique for a single element or that are shared among all the elements that were the types overlap with each other right? There, my first approach is to try to map a system with a with every feature either unique or not, it doesn't matter. So an input system with an input receiver, an AI system with a finished machine, a movement system with a movement components and so on. Then I find that, for example, the rendering system in a 2d game requires us to have a position. So I split the movement component into parts, for example, I split it in a position and velocity. And I find that the rendering system uses uses both the sprite and the position. But first approach is to try some things are obvious, because they are the same in every game. So I don't start every time saying, Okay, I will use the only movement component. No, I have to split it. Okay, I know that I have to split it, because it's more or less the same in every in every game. But my first approach is to try to match a feature to a system so a component to a system and then I split them as needed, and only as needed, and only if it really give me some benefits, some advantages, because sometimes, so I prefer to keep low the number of components, I don't want to work we say in 1000 components, because it's really confusing, especially when you're on a team. So I try to find the right balance between the number of components and the number of system, how they access the data with each other, then when you have something that works, you sometimes find that you have a bottleneck due to how you read data from another component. And therefore you find that splitting a component in two parts. And so into sub components can help to remove this bottleneck. And so this is another reason for splitting and so on. But this is something usually you find as you code your game, as you implement things and measure and look for bottlenecks. I try to avoid premature optimization, because it's really something that will make me never finish a game or something.

Anne van Ede  37:47  
Can you give me an example of that kind of bottleneck? Because if I make a design, I need to, you know, think ahead as well. Something like do you mean only a performance bottleneck?

Michele Caini  37:59  
No. So for example, you find it, you have to read some data from a component, for example, you have a system that acts as a component to update one of its features one of its data members. So imagine a component with 10 data members, and it has only to update one of them. And you have another system that wants to access this component to read some data. Because one is, is reading and the other one is updating, they can't really run in parallel, even if you know that they won't compete, but it's not something safe to do. So if you split the component into parts, you can make them run in parallel, because you have the system that wants to update for example, it's speed that can there's a write access to a write requirement on a type and the other system that read that the requirements on different types. And so we can just go in parallel. So it's matter of performance, but not in not the easiest way. Not in terms of cache usage, but more in terms of I don't know multi threading and things like that. 

Anne van Ede  39:12  
Okay, cool. 

Michele Caini  39:13  
Yeah, cuz, okay. Cache usage is something that helps a lot. But to be honest, it's funny to see how people talk about ECS because they focus only on Hey, if you do that you can have the best cache usage ever and you will never have a problem okay, but it was for technical demo like the ones over Unity. In real world projects you have other problems and therefore cache uses , yeah, it's fine to better chache usage but you also want other features that make you have better, you know, better multi threading and things like that. cache usage is is not only, not your only, you're single problem.

Anne van Ede  40:01  
Nope. Yeah, yeah. You already answered those. Right. So I do see we're getting on a bit in time. So maybe you have to make the answers a little bit shorter. Otherwise, we'll, we'll be here in three in the afternoon probably. What is your biggest misconception when you're designing for ECS?

Michele Caini  40:29  
What do you mean? 

Anne van Ede  40:36  
Well, that you thought, oh, this and this is going to work, this is going to make it better. And then you found out this makes actually makes it worse.

Michele Caini  40:49  
I can probably the main prolem I find is to when, when I try to teach you to teach you about these years to students at the school in Rome. And the main problem I see is the way they try to split components, because it's, it's really something, as I said, ECS is very different from what people are taught, usually at university schools, also from the web. So the main error that I find that I see from others is about how to split things and how to make things work, because they usually want to use the object oriented techniques in the ECS, so for example, can I put a base class as a component? Or can I split these components in 1000 component just because so there you have a single data member for every component. And this is the hard part when you try to teach about ECS to people. At least they're the hardest part I found so far.

Anne van Ede  42:07  
Can you tell me some pitfalls, some things to absolutely avoid when designing it for ECS?

Michele Caini  42:12  
Uhm, usually, it's all about premature optimization. So trying to split things to an extreme, time to focus only on cache usage and things like that, because people get very excited about ECS. And therefore, I saw people looking for the best library, however, to implement a 2D game that has absolutely no performance requirements. So we are human beings, they are seeing problems. But the main problem usually is the this focus on performance. And if you're using the ECS doesn't really matter, the model unless you're working on something like as I say, The Last of Us, Ruby games like these, when you use ECS, you have already a performance boost that is more or less enough for for your requirements, and your bottlenecks are usually somewhere else. So the pathfinding or the AI of a non player charity, and therefore, focus focusing only on the different formats side of the ECS is usually where people waste their time. 

Anne van Ede  43:35  
Okay. I had some more questions about the component design. But I need to see you answered a lot of them already. Before, so I need to see which ones are still relevant.

Right, you already answered that one. Yeah, I'm just going to summarize what I think your answer is. And then you can tell me if there's something more I think that's the better idea. So my questions are, when you're creating components, how do you decide how to split up data? And you said before, your first concern is like, what belongs together like? Like a domain, like rendering or movement or AI, you split it up that way. You leave it like that and create systems to go with it. And then you go back and see if there's need to split it up further either for performance parallelization, or for some other reason. Is that correct? 

Michele Caini  44:39  
Yeah. Exact. 

Anne van Ede  44:44  
Okay. My next question was, how do you what do you focus on when you put together components but because you split up components, that's not really the way you go about it, right?

Michele Caini  44:56  
I do I decide to merge them to merge two components a single type. By usually because of my approach if the problem the opposite problem, usually I decided to split something. But yeah, sometimes you find that a component is only used in combination with another component, for example, and so it doesn't really make sense to have them split in two parts and I just merge them. This is something you'll find usually when you are really far in the process so but if you start from very large component, then you split them when needed, you have the problem of merging them is really is usually not that big, you know, that? doesn't know it doesn't happen very often. But anyway, sometimes that happens in the smarter, Okay, this one always used together. And therefore it's, it's for me to to merge them in a single component because it doesn't make sense to me.

Anne van Ede  45:55  
Next question is a real question. You already answered a little bit. This is about like low level stuff. So you said you already split when a read or write happens in the same component you wanted at the same time, then you split the component into two? What other things do you consider, like low level stuff when you split up data? So in your, one of your articles, you said hot/cold access. But do you also consider stuff like cache alignment, when you create components or other stuff?

Michele Caini  46:36  
you really, really need to you have to work on something that really needs it to decide to consider these aspects. I, and I'm working on on Minecraft. That is, I mean, pretty, pretty big a game. And we don't give a we don't consider these are these kind of things at the moment. So you see, it's something you have to, to really have the problem before reaching this point. And to decide to do something and no, I usually I, the first, the first consideration for the first thing I consider when I decide to split is about how I'm accessing this data. For example, if I have a component that has 10 data members, and they have a system that only read two of them, probably its worth to split this component into parts so that there is one, one component that only contains the data for the system. And therefore I can run the system alone or in parallel with something else and the rest of the data also, because consider that the system wants to read only two data members. And in it loads from the from the memory component, it has 10 data members. So it's loading a lot of unnecessary data. And therefore splitting in a sense, it may help to improve performance. But again, I try to find the right balance between a performance boost for you can add from splitting the component and the how easy to use it is from you from a user point of view, because if splitting doesn't really give me a boost, and it makes me make it harder to use. But from my point of view, it doesn't really matter unless there is a bottleneck to solve and the specific point. So splitting is something its hard to give you a generic rule, because it's something that is very, very application specific. Usually, you have to measure it to find where you want to speed and whether it matters, what do you want to put in parallel and so on. So I, I don't see an easy way to to give a general rule for that. Obviously, if you already know what you want to put in parallel and so on different threads, you may have you may have to, to find what to split and how. Right.

Anne van Ede  49:24  
And I think you also answered this. My question was when there are multiple options, how do you choose which company component combination you take? That that was difficult sentence, apparently. And I think your answer was if I have the choice of multiple combinations, I take the biggest components.

Michele Caini  49:49  
What do you mean with multiple combination?

Anne van Ede  49:52  
So when I created this question, the thing I was thinking about was, you have a system that uses 10 data items. And there are, say two ways to split it like one third, two thirds or two thirds, one third? And how would you choose which of the two, you would take? Like if there's like a stalemate? Like I don't, it doesn't matter how I split it.

Michele Caini  50:24  
No, it's not always a minor or bigger components, you usually I look at the other system, what other system needed to access the same data part of the data on this component in and also how big this component is? Because if it's if my system needs to read and no two field of a component has 100 fields, okay, I'll be splitting I'll split it because it's really a waste to load and unread fields from the from the memory, if it's reading, for example, I don't know two data members have a component, it has four data members. I don't really care because it's true that is loading more data. But probably the the boost isn't that much. So it must be very a good reason to split it because as I said, I prefer to keep a low number of components rather than having 1000 components. Because then you have humans that work on their software. And they have to it's a cognitive load. 

Anne van Ede  51:25  
Yeah. 

Michele Caini  51:26  
Sounds, it seems How do I you have people there, someone is very skilled, but you have also junior developers in your team. And so you're adding cognitive loads for them is a may be a problem. So you have to find the right balance. Also, in this case, I would work very differently. We were probably in a lot of projects, but I am in a team and therefore you must find the right, I think the right balance for a team. It depends on a lot of aspects.

Anne van Ede  52:06  
Oh, well, this definitely answered the question was how do you keep component design, organized, legible for other programmers, like, keep it balanced? Basically. Right. the next few questions. A while ago, I worked, I did an internship at a company and they had used unity ECS. And their systems were like all over the place. So huge systems and then tiny systems and their responsibility was split over several systems. So I created an ordered version, I split everything up. But for that I use some rules, like a system only has to have one responsibility. And responsibility shouldn't be split over several components, or several systems. In the same way. Are there any rules or rules of thumb that you use to create components like a component cannot have more than I don't know, you say 10 data items or some some something like that some basic rules that you use when you you design

Michele Caini  53:17  
No what you say makes sense. So yeah, I usually try to have systems that have only one responsibility and don't share responsibilities between different system and therefore I try to keep components self contained. So to put in components only the information that are very specific for a single operation. So for example, the I don't know the sprite doesn't contain the position because the position is something that has nothing to do with the sprite. It doesn't matter if we have a system that takes both of them to do its work. But they, I want I will never merge the component a few components a single one because they represent different concepts about the responsibility. I agree a lot with what you say. So I don't like to share responsibility. But I also like a lot to have, like, I mean, it's something I do I find comfortable with, I sometimes have like systems that attaches attached to components sort of message for another system. So an example imagine a game and you have a I don't know the player changes the direction of your of your character of the of the character. So you decide to you have a system that updates the state of the character. So for example, from idle to walking, okay. And these systems, from my point of view shouldn't on some date I don't know the animation, for example. So what you see at video, but it triggers a sprite animation or animation change request that is then intercepted by another system. So I like to split it from a point of view of the system, I like to split responsibility many system. And usually I start with this one to one component and then a hard component for this kind of request that I usually don't come out from the from the object because the requests are something I add later in the process. And they'd like to let component push on the pipelines on request for components that are down in the pipeline. And this is also because it's easy to log what's going on. Because if you put requests and cleaner requests, at the end of the loop, for example, you can have a login system that can track all the requests and can more or less tell you what's happening it also something like, I don't know, a rollback system, the storage side of the requests, and is able to rollback things and so on. So I like to use this kind of model. But it really depends on the underlying model you're using, because some one are very good. And adding removing, for example, some others are very good and linear iteration. So the right model, you should pick the model that fits better your mental patterns the way you like to code. Yeah, so this is not something I would suggest to do to everybody probably know, something was suggested to you to do with the Unity ECS but it's the way I like to do things.

Anne van Ede  56:46  
Yes, I'm going on that question. I'll skip a few. Because when I read your blog post, that's actually the first time I knew archived Ark archetypes. So those things that I learned of sparse sets, which I think are brilliant, by the way, but you already said it a little bit, do you consider your system and your components design based on what underlying technique you're using?

Michele Caini  57:23  
Yeah, yeah, usually, yeah, I do that. I if I'm using a model, like the one of Unity, I try to keep, to find, finding the archetypes and to work more like Svelto does. So to say, Okay, my nose, I don't know, my wolf has these components, and I will never attach another component to this entity. And it has these components until it dies. If I use another system like that of ENTT I am for example, if I use something like Unity, I don't use the ECS two to to share messages between system I use probably an external tool like static queue or something like that. If I use some model like that of Entityx, or ENTT, both of them are more or less fine for this. I like to use the ECS for sharing literally everything so messages commands. When the user presses a key, I create a common comb, a common component attaches to the, to the play of character that isn't who they are, but it is the character is interested in input user input. So I I started coding in a completely different manner. So yeah, I I definitely consider what the underlying storage is. And I code accordingly with what it offers and what are its pros and its cons. So its weaknesses. So the strengths.

Anne van Ede  58:58  
Uhm, I have a follow up question on that. I forgot my question. I had a question. Right? Yeah, I remember. Do you also consider when you split components, because you say, I don't your writing or your video? Many archetypes. If you have a lot of different archetypes, it's very bad because it slows down iterating. And on the other hand, you want to split components that only use like half of the data consistently less, less than half. So, but that would create maybe an extra archetype. If you have a lot of different archetypes already. Would you consider merging some components that you would otherwise have split because it would reduce the amount of archetypes?

Michele Caini  59:56  
Yes and no. The number of architects can be a problem, but you have to work on something very, very, very big. And you have to design your components and have very, very, very bad money or to have a problem with the number of archetypes. So I never happened that I had to merge something. Because of the number of archetypes. It's true that I, when I work with something like archetypes, I don't I prefer to keep only the simulation data within the ECS so as to reduce the number of tables so as to reduce the number of copies between tables and so on. And why on the other side, when I work with something like sparse sets, I, I tend to my connection is unstable. Again, I tend to use bigger component cause, for example, merging, I don't know 10 components in a single query is maybe is slower than when using archetypes. So the larger the components, the better the performance. But also in this case, usually, it depends that my first approach is Do whatever you want. So I do the way I like. And then I measure and start measuring things or speeding things where it matters. Because if you start thinking about what's the best approach to you will never end your application or game or whatever it is. So my first approach is make it work and then measure and find where you have done something that can be redesigned and defined. And by the way, it's very, I'm very, I want to have fun while coding. And only when I have a problem I want to solve it not not the opposite here. I dont want to solve problems I don't have just because

Anne van Ede  1:01:52  
yeah, that's that's the way I usually do it too. But yeah, unfortunately for my tool, that's not an option. That's why I'm asking this this questions that you usually only think of later, because my tool will try to, like do the whole process. Right, I have one more question. Are there things I have to absolutely avoid when creating components or designing components?

Michele Caini  1:02:26  
Absolutely avoid? You? Whoa, this is great. Usually I try to avoid to, of course, to split things, the sweet way of extreme granularity is, is the first thing I try to avoid, because it's a hell to work with. And something I try to avoid these usually also branches in the component A system, because when you're using components, this fits fits pretty well with the design of entityx or ENTT is a little harder to work with we in very large applications. But it's a little, the fits a little worse with with a design of Unity, because it's a device to copy things around the table. So it has this problem. provide branches. Usually I express any information with a component. So if you have, for example, you know, a Boolean and you want to put an if in your in your system, I usually get rid of the if and use the components that as the same, I mean, the same brings the same information of the Boolean, the fact that it exists or not, he tells you where to go. And usually, the two branches of the system are split into sub system or I don't know two sub parts of the same system I usually avoid branches they use components to express exist and things like that. The same applies to enumeration. So I try to avoid enumeration is which when you use multiple components, the process proceeds so when I had one of them, I removed the other one and things like that. I try to to use the components to express everything if possible. It as I said it fits better with some model. But in general, if it's also with Archetypes is not really a problem unless you're working on a very, very, very big game with three performance requirements. Because I don't know it's, I find a little easier to reason about to work with and also to more ECS ECS-like approach so I like to say the site to use a solution. Use it to the end. Another thing I try to avoid is to put my whole application in terms of ECS because I don't like the, for example, the The people that tries to push this idea for which you should design your whole application in terms of components and design ECS from my point of view is just a part of your application cause this simulation fits pretty well with ECS design. And some other parts like I don't know the UI some time. So some other parts of the application just doesn't fit with a with ECS. So I usually don't have unless it's a very small game, I usually don't have a loop that just run systems. The ECS is just one part of my application. And somewhere there is a call to someone that runs the system for the ECS but I usually trie to avoid to make it central in the world application. Because there are things that just don't fit well with the ECS and the component based design, it's how things work, I mean, any it fits very well, when there is really your, your object, your concepts overlap.  If they don't overlap, it is the wrong choice for the for your problem. 

Anne van Ede  1:06:08  
Yeah. Anything else?

Michele Caini  1:06:14  
Try to avoid?

Anne van Ede  1:06:17  
I'm learning by the bunches here. So some things I already know. But it's nice to have someone think about it the same way.

Michele Caini  1:06:32  
Something they try to avoid, I don't know when designing system, system and components. But more or less, we already said everything cause I try to avoid to match different concepts in the same components cause so I am pretty obsessive about the responsibility of a component must contain only the information regarding a specific problem, a specific activity I tried to avoid were extremely large components, but also extremely small components because they have problems, different ways. But similar problems. Also there are things that are specific specific of the underlying model. So if I use something like Unity, I try to avoid using the ECS for shipping information messages and things like that, that could hurt the underlaying model. For try, if I use something like ENTT, I try to avoid large queries with a lot of components. But these really depends on the model you're using. So it's hard to give a general rule for for that it's more like okay, I know what I'm doing, I know what I'm using. And therefore I can design for the best for the for the system. And of course, it is when you're working on something very, very, big cause in general, if you're working on small game, small or medium, large game, medium sized game, you don't really care about these, you just code and let it see maybe a when you want to go on mobile, because there the battery is important. So if you can save one milliseconds to your loop may help but I don't know, maybe I will do that in a second release, if the game is good. And has many downloads, I wouldn't try to either optimize something that nobody will have ever downloads, because I don't want to waste my time with something.

Anne van Ede  1:08:38  
actually funny. I know a programmer who used to work on mobile, he said that they actually sometimes slow down the game, because they would use less resources to save the battery. And then the game would actually be slower, but the battery would be saved anyway, that's it's funny that there's so many different restrictions and stuff. Anyway, 

Michele Caini  1:08:58  
that makes sense. You You also want to, I mean, you also want to see if your game is or if your application has downloads before devising you to do an extreme right if you if you put it in the market six months after your schedule, you have already a problem. So it's better to put it on the market in time and then optimize and release a an optimized version from my point of view. So the first thing I try to do is to get it to reach the goal. 

Anne van Ede  1:09:32  
Yeah. Right. So the next part, I'll asked my questions. The next part is a bit about conversion, from OOP to data-oriented. If some of these questions you haven't, haven't arisen for you yet, for lack of a better word, then try to think what You would do in such a situation? And so, the right, so when do you decide when to port a subsystem a specific subsystem of a program to ECS? Or in this case, when you would decide, okay, this is something I am going to build in ECS? 

Michele Caini  1:10:22  
How do you decide Usually, it's not a matter of subsystem, it's matter of a very large part of the software like in a game, you know that it is simulation part is, is a good fit for ECS. So you start in advance with the idea of putting it in the in terms of components, you design everything in terms of components, then when you find, when you know what system you're using, like something that you can use also for sharing messages or not, you also decide to put, considered so when you use something that you can use to share messages, you don't use to share all messages within your application, you use it use it to share messages between system, for example, when if you want to share a message from a system to the I don't know audio system, you just don't use the ECS because they have your system somewhere else. And probably, it's an OOP design or something like that, because so you it's usually self contained, you find a part that makes sense to me in terms of components. And it's usually a self contained parts, like the wood simulation or things like that, it's not that you wake up in the morning and say hello, despite it, we could define components of who they are in the ECS, because it doesn't really make sense there used to break everything, right. And this is when you start a new new software. The other side, when you want to pour things I had this experience with a cloud storage system to two components and I'm working with a guy Mojang studios to port more and more they whole a game to a component based design, this is very hard to do is long process usually cause us something that is already in production that towards the end, you want to leave early. Most to be one to rewrite it from scratch, right, because you want to change the underlying design from a model to a very, very, very different one. So usually, what they do is to implement the component component based model like a parallel parallel rail as our side the main did what already exists, import one feature at a time, we like to use some glue code that at some point, make you change, way start for go there for a while and go back to the to the old to the old pipeline. And these one piece at a time you port things to the to the component based design base, usually very, very hard in this way you spend a lot of time very, a lot of time is compared to what you spend to design as components, everything from from disk from scratch from the beginning.

Anne van Ede  1:13:30  
I'm I have two questions. And one is from the first part, and you said when you're designing you decide what makes sense to put in ECS, What would you consider making sense? Like what what is the like, I need to break it down like very very far.

Michele Caini  1:14:00  
something then more or less, you you learn as you as you work with this tool, you start to identify things that make sense and therefore the next project you already know, more or less what makes sense and what does not. Usually I told you before it's when you have for example a subsystem or a model where things where you have a lot of actors in the overlap. And it's a good fit for for component based design because you can define the components of the system in you have your elements that more or less substantial from many systems are and it doesn't really isn't a good fit for for things where you have a lot of actors but they are more or less all independent from each other so they don't have sub parts to share. I imagine the when you put everything in a row, you try to find their sub parts and you find that nobody shares something with the others. And so it doesn't make any sense to have components because you would have only one instance of every component, and therefore, it's completely pointless. And finally, there are some parts of the gray areas like UI, people, some some people like a lot to put you UI, also in terms of components, components, some others just don't like it and tries to convince you that it's not a good idea. From my point of view, it really depends. In fact, there are some times you wish, for example, for a small game, so mobile games, so things like that you. Also defining the UI in terms of components is pretty easy and pretty convenient. Because you don't have to have another another system or a parallel OOP structure for the UI to make it work to the with ECS, or in other cases, like, I don't know, large games, where you have very complex rules for your, for your UI or you want to use a third party tool? Like sometimes people just want to use I don't know. IMGUI immediate GUI or QT, do you know, QT? library right? out Cute, QT QT? I don't know I do call it. This one. It's a c++ library. It's also used in games sometimes. Let me show you. This one. Okay, it's a c++ framework, it's how he is using their own little system for the desktop environment for a key desktop environment. And in, it's very used by, I mean, a lot of people and sometimes it's also using games. So if you want to use a third party library, like this one or any other third party libraries is just an example. You, I mean, you can put in terms of comp, of components because this is a fully object oriented library that has nothing to do with components. So it's sad to say, I'm not in there. I don't like religion wars on these kinds of things. I mean, case by case, I decide, Okay, these game and for this game, it makes sense to put the UI in components, so the gray areas in terms of to design their components for other games, we want to use a tool that will make it completely a mess to, to work with components, and therefore we use it as an external tool. And we make the two work together somehow. So some things are very clear, like, the simulation or area of the game is very clear, it fits very well, the component based design, others are definitely not a good fit like the network layer doesn't mean the elderly, it doesn't make any sense to have components there. And now there's a gray era where you decide on base to base and application by application reason is fixed the room for that. At least from my point of view, 

Anne van Ede  1:18:18  
Okay. Yeah, the the other question is, funnily enough also the the question that is next on my sheet. So, two in one, you say for for Minecraft, or this is what I understood, you split it up, in part, the refactor the report, basically. And you said that takes a lot of time and effort and you use a specific part you port it to ECS and then you loop it through it and then part by part you port ECS? How do you decide how to split the port?

Michele Caini  1:19:00  
Usually, you try to refigure application in terms of components. So you will interface easy because you have an application in this case, we have an application that is 10 years old, so you more or less know what's seen in this in this game. So you try to find what would be the components, if you started the game from scratch to tomorrow. And when you identified more or less the components, you of course, you wrap your library, any way you write your ECS layer, and starts political usually in these kind of games, if you are not coding with components, you are coding with object orientedprogramming. So you have these God objects with tonnes out of of data members that are less popular for them to the root of the hierarchy. And so you start within these, the getting these data members for the hierarchy and defining yourself components, and you have in the hierarchy, like in the update, usually an object oriented, you know, you have these hierarchy with an update an update function, usually you have this loop that goes up a function for every game object and before at the end or somewhere in the middle, you also invoke the update function for the ECS part, so you have these two, two orders that are just running parallel and you start identifying the with the components will identify it, you start removing a piece at a time from the from the hierarchy and creating components and moving the, the also the logic that is some some function of your hierarchy, you remove also this function and put the logic in an external function, that will be your system, of course, you have to rewrite it a little bit, you just it's a very long process, but your one piece of the time you end up with a complete, empty, empty basket for the game object, that does nothing that you can completely remove it, usually you start from the leaves anyway. So you don't start removing things from the root of the hierarchy. Because it's really risky. You start from the from the handle directory, so the the leaves of there they are your your tree and in you so you can get rid of the nodes of the time, you just split a piece, speed another piece, remove another piece, and you find that you have in order this is empty. And since it has no children, you can remove it from the hierarchy. And so you see that you are hierarchy stars, did you seem to the little at a time on the road. But it's a very long process. 

Anne van Ede  1:21:59  
So I understand correctly. So my voice is my voice decided to not like me. So you, you leave the objects with our updates loop as is and you start moving functionality out of it. So because that the reason I'm so surprises because I would think it's the other way around. But maybe that's because Unity doesn't allow something like that. And that you would like take the whole object and move one object at a time and create systems for that. So instead of

Michele Caini  1:22:42  
No, no, no, not the whole object. Now imagine you have a, your game object contains, I don't know 10 members, one contains the the position so a pair receives position. I don't know the velocity and it already contains all the data you will put in your your components, right? They are just spread around somewhere in the hierarchy. So you decide tomorrow, I want to create the I don't know the movement system. So I decided to identify because I of course I identify what are the components to for my game. And it is this is usually easier because you have already something that works. So it's very, very easier to identify the components and you decide that you want to move the the the position, so you just split the position from the from the hierarchy and put it into the component. Of course, you have to decide when and who is in charge to add the component to the entity because the entity will be associated to the game object. So usually, you have a Glue Code makes the entity and the game object communicate together to share data and to attach and remove components when needed. And this is usually what made you start to degrade the stuff from object oriented to to components which can just get everything emigrate, everything unless you're working on a very small game. So you have to also implement all these new code that makes things worse in the meantime. And that's it you move these information, you move the the logic for the for the for updating the position, for example, for updating the transformer, whatever you're using, in a system. So you have now your components and your system and you have you just need to decide where and how you want to update it. So usually it's application specific, especially if you have an already running application because you could have some constraint for updating the position so you maybe want to update it before or after an independent So in the process of migration, you have to respect the constraints that were set for the for the hierarchy. So its a little, it's what makes the migration hard usually, because you have, you can just decide, I will do these things like that, you have to decide I want these to work like that in the future. And for now, I create this component, the system and in the meantime, have to respect all the requirements for the hierarchy, okay, so sometimes when you migrate things, you also has some pieces of code that are there just to make it work with the logic of the original models of the OOP model, for example. And only when you finish them in when the migration is over, you find that all these these piles of these Glue Code and these pieces of code mean to make it to the to make the two models work together, you can remove them and get rid of them. So you write a lot of code more a lot more code than what you would write otherwise, starting directly with, I don't know components or, or giving me the with a object oriented programming. In anybody, it would also be the performance and the flexibility, though, so be worse than what you had before. And what you will have at the end, because in the process, when you're moving from one model to the other, you have the constraint from one side of the constraint from the other side. So it's even sometimes slower and harder to work with. But if you decided to do that, maybe there is a good reason. So you can accept this. 

Anne van Ede  1:26:48  
Yeah. That was very interesting. That completely flipped my my way of thinking upside down. So thank you very much for that one.

Michele Caini  1:26:57  
How would , how would you migrate from one model to the other.

Anne van Ede  1:27:02  
Well, the problem, why I started thinking this way, Unity controls a lot, like a lot, a lot. And so the systems are run by Unity , and the entities are run by Unity . And you cannot say, Okay, I want to have a component attached to an A game object, because then it which says I can't, I cant do that, I have to be attached to an entity. So that's why I thought, okay, you need to merge the game object completely to entities, and then create the systems that work with that one. And then if there are other in the hierarchy, other objects that need extra systems, you can just, like take one game object, convert it to entities and add the systems or the functionality inside a system, like an if statement. an if statement, like, Okay, I need to have extra functionality in the movement system, because this car much different from the bike. That's how I thought so I would have taken complete entities or complete game objects, move them to entities and worked with the system that way. So doing it the other way around, and starting from the systems and then changing just small parts of each. Each game object that was completely different from what I originally thought was possible.

Michele Caini  1:28:26  
Yeah, I guess the The reason is because you're doing the, you do this on a on something that has already its constraints and which you don't have control, because you are out from Unity , and you have to adhere to its rules. It is to migration is my life, you know, the more the better, the biggest one migration, the one for the closer system and the one I'm working on in Minecraft And in both cases, they have full control on the codebase. So I can do the way that makes sense for me. I see why you are doing you're doing this I like you did but it's I don't know it's very, very hard. And it's kind of odd to me to work like that. Again, I see the reason you for which you do that because you have you're working with something that as some concept some constraints on you. But if you add a usually this migration usually it's easier if you have full control of the code base to do immigration because you can decide into you can have better granularity in split a piece of the time and variable easier than doing it from outside an engine and doing it inside the engineis pretty much easy, pretty, pretty easy to do.

Anne van Ede  1:29:59  
Yes, but you also gave me an idea, because how do I solve the problem? I don't know if it's physically possible in Unity . But if you have an entity with just a position and no mesh, and the object that has everything else, and you build a layer in between, that can let the object know what the position is in the entity, then you can map every object to an entity and just build it side by side. Until at the end, you have no longer an object that needs to communicate, because everything is an entity. So there, you just gave me an idea on how to do it. Either way, the probem would be building that layer in between because game objects are completely self sufficient in Unity , you don't even have a game loop because Unity controls that too. So the only thing that would be difficult is to get them to talk to each other. And but I think that should be possible. I've never done this, but it would be an interesting experiment. So I think it should be possible, but it might be very difficult and performance will suffer until you're completely finished. That's for sure. But yeah, but yeah. Okay. So that's a very interesting idea you just gave me. I almost want to end interview, start coding now. But I have some more questions. Yeah, so you say when porting you have performance loss, but when you're finished porting, there's also some portions that you don't support a lot of porting, like the UI, for example, how do you make sure that you don't lose significant performance between the ECS and non ECS parts?

Michele Caini  1:31:48  
What do you mean, how did I lose performance between the ECS part, I mean, the performance of the non ECS parts are known because they are the same before because they imagined before the migration, I had an update meter that goes, Okay, updated simulation, now update the UI card after the migration, you have an update meter that does update the civilization update the UI card, so they update the UI part has nothing to change nothing in the in the immigration, it has the same performance before because it does, it didn't interact with a simulation before. And he doesn't interact with the simulation after the immigration. So and on the other side on the performance of the simulation, so the part we decided to migrate to components, you can just measure and usually you do that to improve performance. So probably, you already measure things as you port. And so as you decide to migrate, one part at the time, you know, that you can have in worse performance of their own. So when you put the specific part, you can measure the performance difference, you have worse performance and performance overall, because of the gluecode. If you get rid of the glue code, you can measure, for example, how much it costs to update the position in the object oriented design in too much it costs to update a position after the migration. So you know, as you move things you already know if it's worth it, or if you should start with migration because doesn't have very doesn't have anything to do your loop. And usually when you end with your migration you, remove your glue code, you know that your system is going faster than before. You don't anymore, they glue code. And so overall, you should be a better usually. If it's not better. You have a broader you do something wrong somewhere? You you'd be you'd be finding these.

Anne van Ede  1:33:45  
Yeah, you're absolutely right. I actually read over one word in my sentence. When interfacing between ECS and non ECS. So when you when they do need to talk. That's the that's the question I actually wanted to ask

Michele Caini  1:34:07  
when they Well, let's let's get a UI, the UI for example. Okay, so you before this day immigration, you have the UI and to to present something on the screen, the UI has to query the game object, so it has to make a lookup for some information. And the lookup is something like okay, where is the game objects make a change in memory a skill for the data in after the migration, your simulation, we still offer an API to for random accesses. And this is usually pretty important. This is something that when you see presentation about ECS a commercial presentation like that of Unity people just focus on linear axis cause let's let's see how fast it is to to go over all the components, but you have a lot of random accesses in your in an application usually, especially in line large application. So if you the loss of performance mostly depends on how good is your underlying system to because I mean, DPI is just a nice interface to get data from your underlying system, right? Because they want the data for the payer character, you find the entity that has the I don't know, player character tag, and you get its health, for example. Okay, so you must see depends on how good you are and is your belief system to fall at random accessing, so getting randomly data from, from the repository from from the registry, you can measure the amount of time you spend before the migration and the time is spent, because if you hide it out after the more or less it, usually, you try to have to, to separate these parts. So in a in a software, in general, this isn't all about games, into good in the middle and nice API so that you can change everything behind it, and you didn't have to touch the code in the UI. In this case, you can easily measure how much it costs to access the same data. And if you find that there is a performance loss, generally, it may happen because usually random access in a ECS model is slower than in a game object in an OOP model. Not necessarily, but it generally is slower. Usually, it's not that slower. So you don't really care because what you did the performance boost you had for after the migration such that the performance loss on the random query for the UI is completely different. But you can see, after the migration, if you find that it's the bottleneck, somehow, you can still try to improve your random accesses. So for example, by offering stable references to components somehow, and therefore you can have these kind of fat references that are somewhat stable, and avoids a lot of indirection. So you can throw out many techniques to save some itteration  when you're doing random lookups. Before you can try to fill the gap within the the two models for the communication with other systems, other types of components.

Anne van Ede  1:37:42  
Okay. Um, have you found some code maybe in Minecraft, or there was too complicated to port? And what would make when would it be too complicated to port?

Michele Caini  1:38:04  
So far, I made this to migration. And I never stopped it. There are some some things that are harder to port, and others that are very easy to port. Usually, it's hard to port when we when, when you define flip the problem on its head, when you define things in terms of components, you have some components that are shared between two or more systems right, because if you have one component that is using only from our system, this is the easy part to port, because you can easily extract it and make a dedicated system. When you have things that are shared between many system, the more systems, they share the same piece of information the harder, it's usually to port, because it's not a just a piece that you can move easily in a couple of days. But it's a large change and affects a lot of parts of the code. And so it's usually harder to make it work. And not impossible because at least I haven't find yet something impossible to port but it's sometimes very, very hard to port cause, especially if you are in a large in a large team, because you touch a lot of parts in your code. And therefore when you try you or someone else try to wear something upstream, you have kind of 1000 conflicts to solve and you never recently have but this is another problem. A guy's only days tomorrow. Let me finish this work, to seeing a synchronized effort with your team. But usually you can reach the hand just the harder it is the the more you have to clear to focus on what you're going to affect what parts of the software are going to affect so that you can really say guys This part don't touch this part for some days because we, we avoid a lot of conflicts of problems. But it's usually nothing impossible. It's if you if you pick something that makes sense to express in terms of components. It is impossible to port it in a component based design. Of course, if you are doing that for something that doesn't just just doesn't fit the model a everything is impossible because you have something something doesn't make sense. So yeah. Obviously, I can't tell you about Minecraft, specifically. So I think I try to

Anne van Ede  1:40:38  
No, no, I understand. I don't want you in jail either. See? Yeah, this question. I'm not entirely sure how to ask it. So the question is, Are there things that are off limits when interfacing when conversion to data? Like? How to explain this? 

Michele Caini  1:41:09  
Yeah, what do you mean?

Anne van Ede  1:41:09  
Yeah, I have this thing in my head. But it's it's difficult to explain what I'm thinking of. Also, I had this thought, like, two weeks ago that you want to port something, and it needs to talk to? Well, the UI is is is an example. And when would you say okay, this talking between ECS. And the UI is so difficult. And you shouldn't want to port this part. Do you understand a little bit what I'm asking?

Michele Caini  1:41:50  
Yeah, maybe. I mean, it's not a matter of difficulty, usually, because I mean, we are developers, we are paid to write software. So it doesn't matter how difficult it is, if you are paid to do that, you should do that sooner or later unless they are asking you to go to the moon. But usually, it's a matter of it's off limits, because it's using like a technology like, cute, cute. And that doesn't make sense to to port this part to component based design. So it's off limits, but we not because of the how difficult it is to port, but because of how it is designed and what we want to achieve at the end of the end of the process. So yeah, it's not a run about difficulties to report something. Usually, there are themes there. Yeah, as I say, sometimes, when you have the components that are shared by many, many systems, they are very difficult sometimes to port but you don't give up just because it's difficult. solution could be too Okay, I wanted to have this component at the end of the whole process. But defining this component as well, right now in porting it is very, very difficult. So I could, so I could get this data, the data that I would put in this component, and define multiple components that make the porting process easier, because if I split this component, multiple parts, I can split the for the problem of porting this feature in multiple parts and doing something so this is for example, an approach to address the few things that are more difficult to do. So you split you port and then you merge after the split and you recombine everything so the process of porting can be done in multiple steps. It's also pretty nice when you are in a large team because you only affect smaller part of the of the code. And it's more work for you because you have to rethink your logics play things, move more things. Be sure that everything was more right view code and then merge everything when you're done. So it's more work for you but makes things easier. But you usually don't decide to not move something because it's difficult you decided because as I said it's other other reasons like here I want to use a library like UI that doesn't make any sense deport them and things like that. But it is something you do before starting the report. When you decided there's something that needs to be ported you port it, it doesn't matter.

Anne van Ede  1:45:02  
Then I have one last question about this subject. Like with previous ones, can you tell me something that absolutely avoid when porting?

Michele Caini  1:45:17  
Yeah, the first thing to avoid is to port something the takes a lot of parts of the code especially if you are on a team, this is the first thing to do in Minecraft they are very, very far I'm just a contractor so I'm in a nother rise to make some dishes decisions, I just try to suggest and then we discuss and get approved but the on the on the other software that I ported, it was a it was an employee of the company. And they had arrived for deciding on these aspects and we was something like 10 people or something like that. Important, the first thing to avoid is to have large changes. So better to splitand to add more to the port process. So delay a little the end of the port and have to write more code than making large changes that affect a lot of parts of the code because it makes both porting and developing new feature pretty impossible and hell really. Otherwise, you have to stop completely the evolution of your project and decide, okay, we spend six months the board the prod the software, and then we start a new feature. But this is usually not what the market wants to use. So don't do

Anne van Ede  1:46:44  
Any other things to avoid?

Michele Caini  1:46:49  
If you are on a team, this is the first things to consider. The other thing is to probably I suggest you to avoid, is to just start to port and let's see. it's better to make a proper analysis before start porting and find exactly what you want to port and what you want to leave in the object oriented model or what areas he uses. Cause it's not something that you can decide in the middle of a process, these things will roll back everything, because it makes things very, very difficult. So you have to to have a plan that usually makes you smile, but usually it isn't what happens in the gaming industry because you start a game. And then after one month the game is something completely different. And other another month you're working. I don't know I'll be completely different. Now your games are with completely different character. So it's not planning it's not really something is in the game industry sometimes. So for these kinds of things, you have to plan very carefully what you want and how you want to do things otherwise you will never reach there. And other than this, there arent many things to to avoid. If you are alone, it's absolutely easy to do and you don't even have to plan that much or to care about others. So it's very easy if you are in a team I think the most important thing is any small, small porting small pieces at the time and even if it takes longer, it's worth it at the end because otherwise your your fellow will hate you forever. Yeah, he's a warranty for sure.

Anne van Ede  1:48:45  
No, um, you say you make a plan on what to port and what not port? Can you say some things that you consider when making a plan.

Michele Caini  1:48:56  
And usually it's Yeah, then the dependencies we also

Anne van Ede  1:49:04  
Or things you put down in the plan, like the things you plan upfront and things you leave for later,

Michele Caini  1:49:10  
Well you first the way you plan what you decide what you want to do or what you want to port. And then usually it's also trying to find out the order in which you, because I told you it's easy when you have something that already exists to find the components is very easier than when you start something from scratch. So, this part that part is something you that that can be an advantage for you. And so the idea is that you identify your components and also decide the right order for porting things from one model to the other. In what defines the order usually are not the constraints on the ECS side because if you are good at designing systems and components you You don't have many dependencies, right? You have these problems for which you may have to split a component multiple parts to to move smaller pieces of code. But there are many dependencies between a system and components. So what makes you decide what the order is for porting things is usually the constraints on the, so the amount of code that is involved by a single, let's say component, when when seeing on the on the object oriented side. And probably, you can easily identify some things that when moved affects not that much the OOP beside. And usually you want to start with something that makes you feel happy, because it seems to work. And then try to because they are the easiest and easiest part to port and then you start to split larger parts, when you have something that workes especially in a team makes the team feel like they are they're doing it because if you start with something big, it seems stupid. But when you especially with junior developer K, you know that sooner or later you do it so you don't really care. But with a junior, if it doesn't see that, if he doesn't see he or she does see that something is working is getting to the end is slightly discouraging. So you want to make things and then you have also something more serious, like dependency is the fact that it is moving something has on the on the hierarchy. So you want to organize things in a way that doesn't break everything. And you can move a piece at a time. Usually, you as I said, you want to remove the final node in the hierarchy and and move back to the to the root because if you break the root, you could have a bad effect on the on the hierarchy. So you start. But you have to balance these two aspects. So something that it seems to work and something. Make it work.

Anne van Ede  1:52:18  
Yeah, I'm a bit of an outlier there. Because when I first got started on ECS, it was unity ECS. And documentation was barely was pretty much non existent. So I spent two weeks before I got anything working. It was the worst two weeks of my life. But the best moment when I finally worked

Michele Caini  1:52:41  
like that. Documentation is pretty...

Anne van Ede  1:52:44  
It's better now. But at that time, like they were going through versions so fast and the naming of jobs and stuff. And it changed so fast that the half of I was also stuck on one version, because the entire I was also working in a team and they all worked on the on the specific version. So I couldn't go on to like there were eight versions of ECS in my in my unity version, and then the rest was in the next unity version, but we couldn't port yet. Because the company actually that was mistaken. We could actually port so we did that. But I could half of the documentation was too old. And the other half was too new. Exactly. Documentation I could use. Difficult to say yes. 

Michele Caini  1:53:38  
Oh, yeah, yeah, you were when you were young, we want to see something that works because it's Yeah, I'm doing you and when you get older, you just say okay, sooner or later it will work. I don't I don't really care. Because I don't know, I have a son at home and they and they like to play with something else that is that matters in my life. But I see I'm I mean, I am really. I'm still excited when something works. So it's also I will show you my full support for a spear for people like me that is in the job industry I feel ready enough code. So I won't tell you how long your but having something that horses make you feel like you can reach the goal. So it's always something good to have. 

Anne van Ede  1:54:28  
Yeah, I had to... it's not an English proverb. I don't know the English equivalent, at least I had to completely grab it and not let go. Because if if I like you said if I would have given up after something not working and would never have been able to understand Yes, yes, as I do now, but also the fact that I spent two weeks like this doesn't work and that this will work and this doesn't work and that doesn't work. means that when I finally made it work, I kind of understood the whole process because I failed at every single point. But then when it finally works this best? Yeah. So the next part is, for you, this is probably going to be a lot of different versions, because it's about coding and naming conventions. So in ECS, it's changed a bit. And unity, sorry, in unity, it's changed a bit. But it's basically okay after the class name of a system you say system and then after with a component, a name component. But are there any naming conventions like that, you know, for the you use?

Michele Caini  1:55:51  
No, no ENTT, no ENTT that doesn't have any set any requirement, you can do whatever you want. Just like a container entities, like if you're using a vector, just a container. So you you will name your components as you want in your systems, you want Entityx the same, he has a requirement or systems but not on the name of the system rather than the your system, they have to inherit from a base class or something like that. And remember the details? Maybe there's no requirements on the name of the system? in general. This is a another question because naming conventions and things like that are pretty much company specific. So if you if you're working for a company, they have a policy usually larger, the larger the company that is employees would define it it is and And usually, I have seen companies or games where the components were just plain names like position, someone else wants the to put the component word at the end of the of the type and the same for the system but it's it's not something commonly, which people agree just something on which we you find in a company and someone else decided that this is their policy and you just adhere to it unless you are the one that decides and then you can decidefor the best of what you like, but usually, I don't really remember what we what we use in Minecraft. Let me check. Really I don't know if I remember it correctly there is a component at the end. Yeah, like the registry because they have a wrapper, and the registry. The registry? So the wrapper has more or less the same name for him dp and the components? I don't I don't find them now. Because I was working on other teams that they can find them. Okay, I'm completely in it. That's fine. Oh, my, oh, that's in the other window. Okay, it should be yes. Everything is terms with the name? Yeah, everything as the name component at the end. So it's very company specific, I guess, is not something if you ask me what I would do, I don't like to put the name component at the end of the component type or the system or the end of the name of a system? Because I mean, it's a system I know, it doesn't It's like putting the I don't know, the the character or the when you when you define a variable. I don't remember the name of these these approach. When you put the character like b, b, something to identify to say that it was a boolean value so that when you don't know the type you find from the from the name that what is type. And this is remembers me of this approach? Because I see that okay, it's something component, because it's a component. What do I know? It's a component what, what Yeah, what should he do? So I don't like his approach, but it's my taste. 

Anne van Ede  1:59:44  
Yeah. And then how do you if you wouldn't do that? How would you when you're porting clearly separate the new code from the old code. You're not

Michele Caini  2:00:02  
This is a completely different question. In this case, it makes sense to find a way to identify what is a component and what is not. So in this case, it makes perfectly sense to use the word component or another word to identify what's you ported, or in what you didn't or otherwise, you can also put everything up. Nowadays we have these development environment, that helps, that helps us a lot by coding, so you can also avoid adding the component, the component word, type name and put, for example, the classes were indentify, your components under the same directory, called a directory component. So you see that that five comes from the directory named components. So this is something during the porting process you you need something to identify what is from one model what is from another, of course, on the other side, when you develop something from scratch, you just do whatever you want. Because you dont have the problem.

Anne van Ede  2:01:18  
I have a double question here somewhere. Is there any other kind of coding or naming convention that you use? Or would like to see? Because you said it's a good point that you it's company specific, but if you were the one deciding it that you would use?

Michele Caini  2:01:41  
Usually, I'm not that focused on naming, things like that. I mean, if I use it to, I'm from c++, so I am in a world where people really fight because someone uses the capital letter in the class names and someone doesn't. And they decided to follow the same policy of this standard library. And so to use those No, don't don't use capital letter capital, right? Capital letters. So I mean, these kinds of warsthat I don't care, really, that I don't care about. And just I'm using a tool, you're developing a tool that helps me to pour something from one model to the other. You have your policy, you have your, your your rules, and you spit out some code that is I don't know, the component part for the hand. Okay, it's fine for me, because I've used your tool I read the documentation. I dont know that is, is what I mean, if I don't like it, I can just, I mean, change the name of the file that you produce. For me, it's not a great problem. If you haven't seen it, you could give me a chance to set the name I want at the end. So I can just decide to not to not use an appendix or to use the appendix. I don't know Alan instead, instead of components or to put Michele in every component, diver or whatever I want. So it's, it's more efficient, have the fool you, you offer me but I don't really care if it doesn't have this feature. Because, I mean, if it does its job, I don't really care about the name. And a lot of people complain because I call the registry registry, but Okay, okay. I say I like to do the name. Let's see if you don't like it, use something else

Anne van Ede  2:03:48  
Yeah. Okay. Um, then I'm almost through my questions. Is there anything that I haven't asked about, that I absolutely need to avoid in your eyes like a pet peeve or something that you've seen so happened so many times, like, Oh, please, please don't do that.

Michele Caini  2:04:13  
Working with components?

Anne van Ede  2:04:16  
Yeah working with components or ECS in general.

Michele Caini  2:04:24  
The things I say more often is don't care about these. Because usually the you people start using ECS not because of a not because of its flexibility, but because of its performance, because they have a loop that spans three milliseconds and they want to loop the spans two dot eight milliseconds. It doesn't make much sense. I more oriented to the flexibility it offers to me. In in, people started using ECS because of performance and therefore they are very, very focused on finding In the best solution in terms of performance for everything, and usually where they always find, I always say also to students, but also to colleagues and so on, is don't care about it. Because you are already using a tool that offers you good performance, do something that the way you like you that the way that is easy to use for you, then if we we are using a model that is that offers a lot of flexibility so that it isn't a problem to change what you did later if it's a bottleneck. So don't start to do things complicated to it can be also complicated for your colleagues. Just because just because you want to wish you don't need you don't even know what because maybe doesn't really have something just theoretically better in terms of performance. But it's nothing to the end to the to the whole process. So do things the way they are easier to work with, then, because of the flexibility of their system. That is what really matters in these systems. We can spot a bottleneck and change things when needed. This is my usually the most common advice I give to people and the other side that how can make these very, very performant and make it a what's the best solution? In terms of performance is the most common question. And from my point of view, so the most useless in general, because it's not what you should focus when working with ECS. Because you're just using it to give you the performance you need. So start using it for what it is a way to reach best flexibility.

Anne van Ede  2:06:51  
Okay, um, is there anything that you think I should know about ECS design that I haven't asked about anything that's popped up?

Michele Caini  2:07:02  
Um, no, probably, if you haven't done it, but I think you did it already. So at least from what you said, is to focus on the different models, because different models offer different functionalities, different features, and also in terms of multi threading in terms of what you can do and should not do with a specific model and so on. So if you want to also, remember idea, your goal was to somehow implement a process to for a migration from one model to the other one. So knowing was the final final design, you want to reach the the underlaying one can help you a lot to know what and how to port things from one model to the other. Because it's fine. I mean, you want to do that for you. And if you so you want to use them if your case study very, very well was 100 decode and try to have very, very clear what are the strengths, the weaknesses and strengths because it's very important otherwise the races that you helped me to put something, but the point is designed in such a way that is even worse than what I had before. Because you're using you're doing things that doesn't fit at all. So looking at the underlay model is very important, this kind of things. 

Anne van Ede  2:08:29  
Yeah. Okay, that were all my questions.

Michele Caini  2:08:37  
Thanks to our because I used to talk a lot.

Anne van Ede  2:08:44  
That's okay. I also learned a lot. And indeed, what you said, My, the tool want to make, I have like three parts. So I have a part where I get all the data that I can from the code, like how did they data, all the information I usually use because it gets the information from the data. If I say data from the data that's confusing, so the information. How is it used and in hierarchies and stuff, then I have a part that gets from that information with some basic rules, like I said in the discord, some database normalization rules on how it is used and like you said like combinations and what is combined and what is not. So which entity would have what components and stuff like that. And then the third part would be more of a planning part. And then I would use what kind of platform there is. So I will be focusing on unity because I do this research at a company and they use unity. But if you can, I want to make it so that you can plug in like a profile and then I would be making a unity profile. But you could, if you were interested, make like an ENTT profile or Entityx profile. And you can decide what you think is important. And that's why I asked these questions. And I'm very happy that you've worked with so many. So you can like make distinctions like this would work for that. And this would work for that, then I can make sure that that profile would have enough options to cater to many more people, and then I would plug it in, and then it could make a design specific for unity in this case, so that is kind of thought I didn't know, before I read your articles that there was this big of a structural change. But I already thought like, oh, there has to be differences between unity and the others. But I didn't know they were like this structurally different. So it's even more relevant now than I thought before.

Michele Caini  2:10:52  
Yeah, it's a project. It's really interesting, and also really ambitious. I mean, they wish you the best the great project and keep me up to date, because it's interesting. Let me know when you're done, send me a copy of your thesis, or. Yeah, I'd be happy to read it. So dont forget about sending the copy. So feel free to reach out if you have any other question. If you have any other tabs. I mean, we can have another chat or I can review by me when it's time to Don't worry, you don't. It's not a problem. So feel free, if it can help you. Okay,

Anne van Ede  2:11:35  
thank you. I might take you up on that if, like I said, these are the ideas I have. So I want to implement this basics. And then at some point, I will have implemented everything I can think of, and then I will test how well it works. And then maybe I'll come like, Oh, I have this and this but this and this, and this doesn't work like I would and then I will just throw up ideas. Would this work? Or would this work? And then you can maybe help me? Maybe I should discord or something. But yeah, yeah, I didn't know there was this community, That's all ECS enthusiasts.

Michele Caini  2:12:13  
Yeah, I'm not very active in the community. Because usually, these kinds of communities are religious wars between this model is better, these other is better. And so I try to avoid discussions. I'm not very active, but you can ping me in private or publicly. But it's not for me. I dont have many time to, to spend on these kind of things. I did it in the past when I was younger. I prefer to spend my time I don't know, my son or some not  random people on the web, it's not the right way to spend your time. 

Anne van Ede  2:12:54  
No, I'm on the same note of staying in contact. Would it be okay, if I added you on LinkedIn?

Michele Caini  2:13:04  
If you add me?

Anne van Ede  2:13:05  
on LinkedIn? 

Michele Caini  2:13:07  
Oh, yeah, sure.

Anne van Ede  2:13:10  
Yeah. That was it for all my questions. Do you have any questions for me now?

Michele Caini  2:13:18  
No I didnt mind you in the process, maybe as I said, I'd be very, very glad to read your your final work. Because I find, thought you interesting, really, really ambitious. I didn't know if I would be skilled enough to do that. So I want to help you to reach the end. I find, helpful. No, I did my question where we were talking, so it's fine for me. And you gave me all the information before starting and during the interview. So I'm fine. Thank you.

Anne van Ede  2:13:54  
Then, again, on a Do you have any feedback for me on the questions or how I present the questions or something that this is my first interview of the of the series that I want to do? So any feedback would be welcome.

Michele Caini  2:14:11  
Questions are pretty clear. To save every issue, you should review the youre the time you plan for for the interview. Yeah, I'm from Italy, and I used to talk a lot by in general there are a lot of questions. So an hour is maybe,  eiteher remove some question or say to people, okay, it would be maybe more than an hour. Because I mean, I'm fine with it's not a problem for some people. Usually, if you tell them that it's an hour after hour they say okay, I have to go Bye bye. Just leave you without your anwers so it's better to be clear before starting to see the question pretty particularly interesting pretty wide to the cover a lot of area so I liked the interview I think you know better than me if the answer really your, your needs so on the on the content of the questions you can have it right from the from my side from my point of view it was a good interview apparently so

Anne van Ede  2:15:40  
Thank you for your feedback and all your time. and have a good day.

Michele Caini  2:15:50  
You too.

Anne van Ede  2:15:53  
Good luck with your son in the afternoon. Yeah,

Michele Caini  2:16:00  
I'm fine. I'm alone at home. Okay, feel free to get in touch if you need something else and good luck with your with your work. I looking forward to receive a copy of your okay. And really, no problem in contacting me okay whenever you need. 

Anne van Ede  2:16:21  
Okay. Bye bye. 

Michele Caini  2:16:24  
I have a nice day. Bye bye bye.

Transcribed by https://otter.ai
