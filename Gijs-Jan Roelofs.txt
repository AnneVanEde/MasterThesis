Gijs-Jan Roelofs  0:17  
Okay, sorry ik heb geen video op het moment, want ik zit even niet op locatie. Ik hoop dat dat geen probleem is? Sorry, ik kan je heel slecht verstaan. Ik ga even kijken of dat aan mijn audio ligt. Jij kan mij wel gewoon goed verstaan? Nee niet echt, het klinkt heel, alsof er een kussen voorzit ofzo, ik hoor het heel vaag. 

Anne van Ede  0:47  
Dat had ik vanmiddag ook al, is dit beter?

Gijs-Jan Roelofs  0:52  
Ja, ja. Heel veel beter.

Anne van Ede  0:55  
Op een of andere reden werkt mijn headset, nu dus vanmiddag, vanochtend wel, vanmiddag niet meer. 

Gijs-Jan Roelofs  1:00  
Dat kan altijd gebeuren, we zitten gewoon in die tijd. Goed. 

Anne van Ede  0:53  
En de webcam die het voorheen niet doet, die doet het nu dus wel, dus dat is wel positief.

Gijs-Jan Roelofs  1:12  
Okay. Je had een heleboel vragen.

Anne van Ede  1:34  
Ik heb alles in het Engels, is dat een probleem?

Gijs-Jan Roelofs  1:40  
Mijn dagelijks werk is in het Engels, mijn clienten zitten allemaal in het buitenland, dus dat is helemaal geen probleem.

Anne van Ede  1:45  
Dan doe ik het het liefst in het Engels. Dan kan ik het ook zometeen makkelijker verwerken in mijn verslag en alles. Eerste vraag alleen, ik zie nu wel ergens je naam, want ik heb geen idee hoe je heet.

Gijs-Jan Roelofs  2:04  
Okay, Gijs-Jan Roelofs. 

Anne van Ede  2:09  
Okay. Hoi Gijs-Jan. Okay, so I'll switch now. And thank you for your time, for talking to me. Like I explained in my messages I am researching, I am researching, converting from object oriented to data oriented, and specifically to component based, like ECS. And I got interested in this like two years ago when I first found unity ECS. And I thought, Oh, this is so cool. But many of my colleagues and fellow students didn't want to convert because they didn't know anything about it was very different to what they were experienced with. And the companies that they worked that also didn't want to convert for the same reasons. And I thought, well, isn't there something that can help them convert? The answer was no, there was not. And I'm trying to do that now. So my research is basically trying to create a tool that does two things, in one, it takes the object oriented code, and creates a plan to convert it to data oriented or specifically ECS, it doesn't convert itself, it just creates a plan. And it also educates the developers at the same time on why it is a good plan, so they can maintain it in the future, and work on it and learn from it, basically. But that's brings me to a very good point, it needs to be a good plan. Um, and there are many opinions about what a good plan, and I'm trying to collect as many as possible to find like a common denominator. And that brings me to you guys. 

Gijs-Jan Roelofs  3:55  
Okay,

Anne van Ede  3:56  
um, so I created this, this interview will with open questions, but I created them quite General, because I'm speaking to many different people, and also people with very different experiences in ECS. And so I try to make them as general as possible while still being specific enough to get information. But if they don't suit your situation, just tell me so we can drop the question or change it or whatever. 

Gijs-Jan Roelofs  4:23  
Right.

Anne van Ede  4:26  
Yeah, usually, this takes about an hour and a half to two hours depending on how much we talk. Is that a problem? Is there like a time limit yet?

Gijs-Jan Roelofs  4:38  
I might need to join a meeting at half past five. But I am more than willing then to pick the conversation up again at a later date if you want to.

Anne van Ede  4:49  
That's okay. I think we should be able to do an hour and a half. But we'll see. Right so for this is for my thesis. So I would like to be able To Use Your name that's why I asked it, so that they know I didn't ask my next door neighbor for his opinion that okay?

Gijs-Jan Roelofs  5:06  
yep, no worries. 

Anne van Ede  5:08  
Also, can I record this interview just so I can type it out later? Just I'm not going to spread it anywhere?

Yep, no problem with that either. 

Okay. 

Gijs-Jan Roelofs  5:19  
If you do make it public, then I would leave, like a notification at least, but I don't have any problem with it in the basis.

Anne van Ede  5:28  
And then you mean, if I released this recording, or if I release my paper with your name, 

Gijs-Jan Roelofs  5:32  
The recording.

Anne van Ede  5:33  
Okay, no, no, no recording is not going anywhere. But if it would go anywhere, I would, of course, like, you know, and ask you permission, for whatever I'm going to use it for. Are there any questions you have for me before we get started?

Gijs-Jan Roelofs  5:49  
No, for the sake of expediency, I'll just let you ask the questions.

Anne van Ede  5:54  
At the end, we can always just talk a little bit, or anything. Right. So just to get started, can you tell me how you first got started with ECS?

Gijs-Jan Roelofs  6:06  
Um, that's roughly somewhere around I think, '08, 2008, were from my summer in my studies, I started exploring game development. And I stumbled upon a series of articles on ECS and data driven design. Coming from I think the game was called Dungeon Siege. And there were a lot of theoretical talks about ECS at the time. And that's where my primary interest started. And I did some hobby projects in a hobby framework, because there weren't any good open frameworks at the time. And that evolved into me, contributing to a successor to one of the earliest ECS frameworks called Artemis and the successor being called Artemis odb. In Java, that have evolved into me collaborating a little bit at the start of Entitas, and C sharp, and talking to all kinds of framework developers throughout the years. And me developing in house to ECS frameworks one more centered around performance, the first one and the second one, more centered about the conceptual designs that ECS allows.

Anne van Ede  7:39  
Okay, you answered already a little bit, but can you tell me how you currently use ECS?

Gijs-Jan Roelofs  7:44  
Yeah, um, so at the moment, we're developing Sentinel two, that's a public project, like a sort of an XCOM clone. And in that we have a ECS framework of ourselves wrapped around unity. That is more reactive in design, essentially. And on the side, I am also developing a experimental ECS framework that tries to leverage relationships between entities more.

Anne van Ede  8:16  
Yes. Yeah. Is that perchange with Sander?

Gijs-Jan Roelofs  8:23  
Um, I guess I collaborate a lot with Sander, the author of flecs. But we're, we're pretty much developing two frameworks side by side. And we do really talk a lot about the internals of both frameworks with each other. But we're both approaching the same problem from two different perspectives, essentially.

Anne van Ede  8:52  
Because I talked with him and he said that I should talk to you, that's why I'm asking.

Gijs-Jan Roelofs  8:57  
Okay. But how's he you? Have you had already had an interview with him or not at all? Or?

Anne van Ede  9:03  
Yes, I already had an interview. And at the end of every interview I ask, Who are the guys you think I should talk to? He mentioned you, so I'm here. Right? So can you tell me all the ECS implementations that you've worked with?

Gijs-Jan Roelofs  9:22  
in projects personally, so not just experimentally just to explore the framework, it would be Artemis odb, Entitas and the two frameworks that I developed myself.

Anne van Ede  9:40  
Can you tell me in one or two sentences, the biggest advantage you see of ECS?

Gijs-Jan Roelofs  9:46  
That used to be performance, it is now design as in so ECS uniquely allows you to very easily iterate on certain design. And it's from a game developer perspective, I feel like it solves a very classic problem in object oriented programming the diamond problem in a very elegant way. And it allows the concept of duck typing in a very nice statically typed environment.

Anne van Ede  10:26  
In the same way, can you tell me the biggest disadvantage you see of ECS?

Gijs-Jan Roelofs  10:33  
One is there's no common language at the moment, for a lot of aspects. And this is partially due to the evolution that ECS is going through in the past four or five years. Two is the fact that the frameworks at the moment mostly focus on iteration speed, and they don't focus on maintainability, as in one of the biggest disadvantage in ECS, is that in object oriented programming, you have a single context for whatever functionality you have, where you tend to at least you have a class and that class is authoritive. You can go to class to find all linked behavior. And in naive ECS. There is no such thing, there's just the component. And you see, as well, in the framework that I have, I could show you some code samples on that as a project progresses, you need to apply certain patterns that help you with reflect durability and reading comprehension. And how do you say that? What's the term I'm looking for? The conceptualization of something like what does a set of components mean? Right? And when is that set of components correct? and such? And if I change that were in the code Do I need to change this? And with classes, or an OOP structure that is statically statically typed enforced and with an ECS, we don't have the tooling yet on the market, I have to say, that really solves this. And you'll see that individual teams tried to solve this. For example, in our code base, we implemented static type checking in the ID to help with this. But it's not a like all the tooling that you get for free if you accept OOP doesn't exist yet for ECS. Yeah, I think that's the biggest disadvantage at the moment. 

Anne van Ede  12:49  
Okay, um, for next questions, I basically put them in four categories. General ECS design, component design, code base conversion and coding and naming conventions for these questions, again, if they don't suit you, I'll try to ask up front before I choose which questions to ask, but they don't suit you just tell me so. Also, just explain it to me like, I'm five because what you might think is so obvious that you wouldnt mention it might actually be that one piece of information that I'm still missing and that I need. Because 

Gijs-Jan Roelofs  13:25  
I'll try to.

Anne van Ede  13:27  
just just ramble. It's okay. If you go on, I have more than once that the, someone who would answer three, two or three questions in one, which is fine. So it's more about getting the information then asking all the questions in order and stuff.

Gijs-Jan Roelofs  13:45  
Yeah, so the way I answered the previous question is a good example of?

Anne van Ede  13:49  
Yes.If you give examples, then sometimes it's not the most relevant for my research right now. But it's still very interesting for me to understand it. So I'm still learning lots and lots of things. So. Right, so to get started, when you're creating an ECS design, can you walk me through the steps you take?

Gijs-Jan Roelofs  14:14  
That is a very loaded question. So this is this is the thing that experience over the past almost a decade, I guess, as lead me to, is that there's a lot of different camps within the ECS community. And you tend to see that one approach is a something that leverages the strength of ECS. As in you can iterate and also that you and I don't think I actually said that last in the last question. You don't need to have a design upfront necessarily. Right as in, if you go and OOP approach, you need to think ahead way more on how those cross classes are going to structure and interact with each other. Because there's limitations on this. And within ECS, you can, you can define a feature or concept in terms of just standalone components, right? By definition, if you're doing things right in ECS, then there shouldn't be any interaction between systems and the components that those systems require. There's a caveat there, because you tend to see that some people, to really leverage on this, make very unique components, you get these like, camera position component kind of thing, or very long names that like, are intrinsically tied to the concept that they want to represent. And I am not necessarily a fan of that. I want to, I tend to want to generalize my components a bit more. But to actually answer the question, I personally tend to go from a behavior slash feature approach, as in, we get a request to implement some type of feature. Let's just assume that it's not implemented at all, I look at the data that is required for that feature. How will I be operating on that data? And what framework I'm using as in at the moment, there's two, two of the major styles that are popping up in the ECS community are the more batched approach versus the reactive approach. There's way more variations on that, but just simplified, I'll just do it in terms like that. The batch approach is essentially the approach that you define a feature, in terms of a system, that system gets a tick at a certain event or condition and then handles is set of entities to do whatever it is that needs to be done. And the examples always show you things in terms of physics engines, because they very readily map to this pattern, right. The other side of the coin is more reactive style, where you essentially use the changes in the composition of an entity. So the adding or removing of a component, and as a condition for processing to happen. And that isn't necessarily tied to a batch of entities that could just be a single entity. So if one entity somewhere in the world, and a component gets added to it, something changes. Now, the semantics on the add adding of a component are also a bit ambiguous. As in, if I explained to you a composition and the components add or remove, you'd intrinsically, I presume, think that it is a novel component. Right as the component wasn't attached to the entity before, but you could also see that as replacing a component, right? And this delves into, into a design that we use, as in for us the values on an entity better said, the values on components on an entity are immutable. But a programmer can add a type of a component to an entity again. So what does it concretely mean, let's say you have an entity that has hit points, component points in that has value 50, you can add the hit points to the entity again, with a new value. And then the system gets a an update, saying that, hey, this previous value existed with it on this component, and this is the new value, so you get a delta. And that's sort of like that's the reactive design. And it's a bit further in progression on what people are doing with reactive design. Now, if you have these two basic things I batching and reactive design and for example, for reactive you have the concept that you can get the delta of a value change instead of just a signal that the value has changed. Those lead to vastly different designs. Right, as in batching is, is often used as an, as an optimization. Someone will probably correct me on this or have a different opinion, but I'll just presume it for this. So if I have a physic system and throughput is the thing that I need, then what I'm going to be doing is designing the components such that the locality of the data is on the entity as a row. Right, so that, I just get a list of, of multiple lists of components as it were. And those lists are exactly the set of components that I want to iterate through. And those lists are contiguous, meaning that there's no gaps in the list or values that I need to skip. And then I'm just gonna define my logic in terms of indices over these component lists. That's the the most basic interpretation of a batched approach. And then essentially, you just run through that list, do the operations, and apply the updates or delay the updates, whatever it is that you want, and then your system gets slotted in somewhere in a well defined graph of systems to execute. The other approach is, I have a UI somewhere. And this UI needs to be updated based on values that change on the entity. Or let's say I have a complex logic, that, let's say it's a unit is moving across a path. And I want to be able to very easily attach behavior to changes on that unit, or I need to do things that I cannot delay until that unit has finished moving, for example, or, better said, I can just use that graph of the system that I normally have for my game loop. Because that unit is moving or being moved in a simulation by the AI. And the AI is just executing that single entity. And it only needs to know that I can give that a position and all side effects that stem from that position change need to be executed, after I've done that position change. So what I mean by that is, for example, if you have a tactical game, it could be that if a unit moves a single cell, that another unit could apply a reaction like Overwatch, or that he falls in the trap or something along those lines, and ECS through that reactive model. The good thing is that I don't need to, what I would normally need to do then is have somewhere in place in my code where I, I define the path for that unit, and I do the steps of that path. And then after every step, I need to call listeners or explicitly execute the logic that happens as a result of that change of that position. While in ECS, what I can do in reactive ECS, what I can do is define a system that says if this position changes, do this thing. And that's something that ECS brings for free, because of the concept that everything is a component and you just listen to the basic concept of a component being swapped in or out or changing, right. So what that gives you is that you can have your pathing system in one place. And that pathing system knows nothing about the reaction that occurs. As a result of that position changing on the unit, it could just be that after every position change, it just checks, is there a component on the entity that says I need to stop now. Or maybe I could set it up in the position component that there's a value that says, hey, stop execution your, executing your path. There's alternative ways of doing that whole message based system, I won't go into that. The beautiful thing is that I can if I want to create a new feature, I can just look at Okay, we have this position system now. I listened to a position component change, I create a new system that does this, it's completely separate. I can just toggle it on or off. And I can test it with different systems without that affecting the original system at all. Right, which is a very clean way. Right? To take several steps back now to how do I go from a problem to code? So the first question that I need to ask myself is what are the performance semantics that are required? How is this feature going to be used? Is it batch or reactive, right? If it's UI, for example, I just need to respond to a change in the world and I need to do that immediately. A reactive system is more the way to go. If you go with a reactive system, then there's also this whole debate on how you want to do your components. Right. So in in a batch approach with a component the component tends to be heavy, right because you essentially want the footprint of the component to be the maximum size towards how your system will use it in terms of so how do I say that? Let's say you have a transformation system, a physics system, you could do that in terms of a position, a rotation and acceleration, yada, yada, yada. Or you could have a transformation component and an acceleration component. Right. And within batch systems, it tends to be, if you don't need to reuse that component outside that system. Right, then you can make the component bigger, because then you don't have multiple arrays that you're going through as an, all the data that you're going through is data that you'll need. Right? So you can dump it in a single component. That's one design philosophy. And then that balances itself a little bit with Do you need to reuse aspects of this. So a lot of people use transformation in terms of scale, position rotation, so we can dump them together, right? Everywhere where you use one, you'll probably need to use the others as well. So we can lump them together. In a reactive design, this falls apart a bit, because the size of the unit that you get an update for or delta for is the size of your component. So if I want to be able to distinguish between my rotation changed versus my position changed, they need to be split. So this is a choice again. Right? So just to bring it back yet again, a little bit. So I start, I look at what's the use case? What if I go reactive? How granular Do I need to be in terms of responding to something? Right? And are there other systems using this, I have, over the past few years started to lean towards not letting performance take the lead. And going very granular, because the design speed it gives me and the implementation time it saves me far outweigh any performance costs that we see also, as in,a game, this is the real, real real problem with ECS, I think, is that all the examples that you see tend to be toy problems. They don't show a full application in ECS. And 99.9% of an application performance doesn't matter or making a change in how you design your ECS or use it, sorry I have to say, doesn't matter at all. It's not something that will measurably pop up. So that's why I'm favoring more at the design side of ECS. Having said that, though, just so it said, there are areas that I fully acknowledge that performance is the primary concern, right, like transform hierarchies, rendering API, yada, yada. And there are also cases where you start with one then you start migrating to the other can be a headache. But the base is essentially, for me, how do I need to use the feature? Is performance really an issue? If not, I'll probably opt for the reactive design. Because the reactive design, to me is more standalone. And the way we use it with immutability ensures that it's even more so standalone than others. As in a common problem that other reactive designs have is that. Well, that's going away deep. Maybe that's the next question for the question. But yeah, like I'm really in from information overloading you on this one. Okay. Use Case, performance, go reactive, if it's reactive, or what level of granularity needed, do I need to react to the change? What am I interested in? Right? am I interested in just the position or don't I care? Like, if anything changes on transformation component, that's fine. And then I try to reuse components that we have, as in can I express this in terms of a, components that already exists semantics that already exists? I need to fall back a bit because the question was purely about components, right? 

Anne van Ede  29:59  
This one was general. We'll get to components.

Gijs-Jan Roelofs  30:05  
Let me because then it's probably best if I maybe share my screen a little bit. Oh, yeah, you've disabled it. So you need to enable it yourself. Okay, give me a sec, because I also need to click some buttons over here.

Anne van Ede  30:33  
It says all participants can share so 
----------------------------------------------------------------------------------------------------------

Gijs-Jan Roelofs  30:36  
Ah I can share now. Yeah. Looks like. Right? Okay. Um, right. So I talked about the problem of concepts and ECS, as in, people tend to work from a system perspective, define a query in a system on certain types of components. And then that's the end of it. And what we opted for is that you that we essentially have central locations where we define the concepts that exist in our code base. Let me see if I have some arch, common archetypes. For example, something is unique in the world, if it has a goid component, right? Something is selected if it has a selected component, for example, for very simple things. And we define these upfront in terms of this noun or the name that we use to be able to communicate and design with each other. Right? We're not just talking in terms of it has a selected component. No, it is this selected featural archetype. I need to immediately note that we started using archetype, internally a little bit before UCS came out. And UCS just redefined what the word means. So with any ECS, the archetype is essentially the specific composition of an entity. And for us, it means more, a composition that an entity can conform to. Right, so an entity could conform to multiple archetypes, right? So something is animatable, if it has a game object, in this case, these are not really good examples, but like faction system. So something is a faction, if it has members and an allignment is a faction member, if it has a team link that it's set up by, right. So you express it in these terms, essentially. Yeah. And then what's important as well, is that we need to double check whether I have anything I can show Yeah. So what we've done is we've done essentially tried to for people that are not as familiar with ECS try to find conceptual similarities between concepts in OOP and ECS. And then if you have a class in OOP, what would that be in ECS? If you have an interface in OOP, what would that be in ECS and more general design terms that we use to communicate with each other about compositions of ECS. So one we identifie a class-like so if something is a very concrete concept, like a unit, armor, combatant, right? Like, like you have classes in OOP. Another is a trait-like so which is essentially a composition that you could set up on an entity that is a very well defined feature, right? Like modifiable, renderable, stuff like that. And the idea being that you can combine these trait archetypes together to create a feature. And, and they, like, the reason why we call them traits is because functional programming uses that term as well for sort of the same thing. And then we have the state, which is something I think is relatively unique to ECS is that the composition can indicate the state of a class if I were to express it in terms of OOP so let's say you have a class in OOP. The problem is that the state is not explicit. You can't look at without looking at the internal of a class to see what state it is in. But what we can do in in ECS is we can define, like an archetype like a query, essentially, and say, Hey, if this component is missing, that represents that the thing is in this state, if we add the component, it'll transition to this state, right? And we have these conceptual states, and a very simple example is dead or alive, right? Something is dead, if its health is zero, something is live as a health above zero. And the idea being is that we use these three things to communicate with the designers that we work with as well. Saying that, hey, if you can express it in terms of a trait, you can mix and match. Right? If you can express them to state, it's something that you can use as a trigger for your, for your logic. Right. So why do I end up at this point, because after I've decided a bit like the batch,  reactive, the size of my components, and whether I can reuse components and such, I try to define an archetype that represents the feature set for that system or the feature that I'm implementing, so that I can communicate with it on others. I can probably, if you want, I can send you a snippet of this because I cant give you access, I cannot give you access to this. Yeah. Let me double check with this, whether I have any interesting things over here, because this is also an internal wiki. Just as a question, like the reactive style programming of ECS, is that something that you've got any experience with?

Anne van Ede  37:04  
I think I've worked with both batch and reactive. But in general, I just don't have that much experience as a whole.

Gijs-Jan Roelofs  37:15  
It's absolutely fine. It's definitely fine. Like I'm just because so, what is a good example? Do I have a good example? Life status system? I need to find the most trivial example I can think of. Yeah, right. Okay. So this is a very, very simple one. So we essentially say anything that has hit points, but is this readable for you? Or is it? 

Anne van Ede  37:47  
Yes, yes I can read this.

Gijs-Jan Roelofs  37:48  
Okay, so anything that has a hit point is what we're concerned about. Let me state that, if it's hit points become above zero, right? We're interested in those entities. If anything, enters that family of points being above zero, we add in the conscious life state. If it doesn't, if it's dead already, right? We don't do anything else, we mark it as life status dead. Like a very simple thing. And this reactive approach, what would happen if I, if I have an entity, E and I do E hit points, hit points, there you go, if I add hit points, then before anything else executes, this thing would now have a life status which equals death. Because all side effects happen at that point of invocation. There are some circumstances on this, which I'll not go into now, because that is very much an advanced concept in terms of delaying operations when you're in a callback, so other families can respond to an entity before it's been changed and stuff like that. If for some reason you do get interested in that, let me know. Let me quickly check on design patterns to see if I'm missing something. Yeah, I also then look at the fact on whether I need the Delta right. So in our system, you can get the previous value and the next value. So for example, in terms of health, you could, you might want to know if the health value is dropping and do something like warn the player for example, similar thing you could have in a stock market system, but if a stock is dropping, I need to know the delta and respond to those types of things. Now that's message based, which I won't delve into now. commands? No, I think. Yeah. After I'd stopped, I also start thinking about terms of what data will I be needing that is not live as in something that is coming in from an asset or something. And I'll think about whether the lifecycle of that thing maps one to one to the system that I'm using, or whether it needs a transformation, right? Like, it could be that you have an asset that just has a mesh, but once you if you want to use it, it it needs to have a cached mesh with pointers to everything, and blah, blah, blah. those concepts then also get ingrained in terms of archetypes, right, as in what stages are these things in? And I think that's roughly the approach because the problem is then. Going further than that, I suspect is, is very much expert knowledge. As in, this already took me a while to explain, I guess, and has a very high level explanation, I'm more than willing to try and see if I can come up with concrete examples that might make things more interesting. Like, for example, you have, how do you represent a state machine? Differes between frameworks as well. Right? Or how do you like for example? Certain, right, how do I say this. opinions are divided on how complex your components are allowed to be. Right? Should they just be simple data? Or can they have inheritance or not? Right, can, should they just be structs? Or should the expression be articulated in operations on a struct? And how do I reuse these patterns? Initially, I was quite strict. In terms of components such as data, they're structs, they're very simple. But it's actually very handy if, for example, in our game, we have a lot of RPG-esque attributes, which we express in form of a range, which is a minimum, a maximum and a value on that range, which is a basic data type. So we define that and define all kinds of logic on it. And we allow that data type to be inherited from another component, right, so as you can see, there's a lot of components here that inherit from it. And we can then generalize things like a modifier system or an ability system to work with that conceptual, primitive. This is a controversial thing to do in ECS. Right, or at the very least, how it's done here with class based design, right? Like, I think now, if I were to re-implement this, I would do this in terms of interfaces and structs. And not in classes, I think. But essentially, what I'm trying to say is, I tried to think as well on whether the feature that I need will have primitives that I need to reuse and other systems or could reuse in other systems. And think on whether I could design my components around that. I like, essentially the equivalent of saying, if I have a transformation component, I'm going to use it using a vector3 and a quaternion. But as those are very apparent reusable data types, but maybe you, we have different ones right for that feature. Right. So to recap, batch reactive batch, a stick thick as possible, without it becoming a burden on the design layer, later, reactive as thin as possible based on what do I need to react to reusing components if they already exist? What data goes inside my components? What is my data locality question? data locality also in terms of, can I stick everything on a single entity or do I need to make a hierarchy With relationships between entities. So we delve into that database normalization question, I guess. Yeah. And then the conceptual aspects, like the archetypes and such. I think I'm gonna leave it at that for now.

Anne van Ede  45:19  
I think you answered about six questions of mine. But maybe, maybe next time just a little bit shorter answer, because I have more than enough questions.

Gijs-Jan Roelofs  45:33  
Yeah, yeah, that's fine. I'll be more direct. That's fine.

Anne van Ede  45:38  
So you basically answered, very detailed how you create components, and how you decide what your criteria for your components are. But when you first started, or maybe recently, I don't know, is there some misconception that you had, that you found out was wrong? What's your biggest misconception when you started designing ECS?

Gijs-Jan Roelofs  46:07  
Everything needs to be about performance. That was my biggest misconception.

Anne van Ede  46:15  
Thats a short answer.

Gijs-Jan Roelofs  46:18  
Feel free to, by, by the way, feel free to interrupt me. Right. Like, just so the last said as well, I have no issue with that.

Anne van Ede  46:27  
Oh, yeah. Is there something one or two things that you think that I should absolutely avoid when creating for ECS, uhm design ECS? And it can be like big structural things to pet peevesthat you get from other people? Please, please don't do that. I've seen that happen so many times. That never works.

Gijs-Jan Roelofs  46:52  
Oh, that's a very tough one. Because the problem is that is that it's I've heard people state things that you shouldn't ever do, which we've done successfully, and not even just proving them wrong. But as in, we would have been worse out if we hadn't done it. And I've seen the reverse happen. I would see, I guess it I'm just gonna follow up with my previous answer. I would look at ECS in terms of what it brings with design. And that's a very broad topic in terms of Can I quickly still implement things with this design? Is my the footprint of my maintenance not increasing? And if you only look at it in terms of, Oh, I have one, I have an answer, I have an actual answer. Don't start with thinking about what it is that you need to model. But there's an asterisk there, like if you're in a if you're in a deadline for 24 hours, and the product is not going to be used afterwards, then obviously, that doesn't hold. Right. But but don't use ECS as an excuse to not have to define a model.

Anne van Ede  48:53  
Can you explain that a little bit more, you're not going to focus on what you're going to model, what do you focus on?

Gijs-Jan Roelofs  49:04  
Well, I mean, in terms of how it interacts with everything else, the lifecycle of that concept, for example, some some people just very quickly, like, the over, the mental overhead of adding a component is the same mental overhead that someone has as as adding a variable to a class, right? But you could make one gigantic class where you dump everything in and then you'd be very, very wrong about your approach. But because ECS makes it's so easy, just to add, keep to keep adding things, quickly removing things. People see that as an excuse to not have to think about the design as a whole at times.

Anne van Ede  49:50  
So you're saying keep in mind the overall structure of your program?

Gijs-Jan Roelofs  49:57  
Yeah, right. Like, 

Anne van Ede  49:58  
What your are trying to do?

Gijs-Jan Roelofs  49:59  
yeah, like The one thing that I always say is lifecycle above everything else. They like, you need to know the lifecycle of everything in your, your setup. And entity, ECS makes it very easy for novice programmers to get started because it doesn't force these things to the front. And you get this race to outstay the chaos of the codebase. Right, where they and the reason why that is also is heavily used in game development is because mostly after deployment, the game doesn't need to be maintained, or or change that much, right, people just make a new project. And there is a hidden chaos to ECS, that needs to be kept in mind.

Anne van Ede  50:57  
Okay. So yeah, you've partly answered this question. But I'm still going to ask it. When you're creating components, when do you decide to split a component into two components? How do you decide where to split it?

Gijs-Jan Roelofs  51:26  
Whether I need to react to the variable, or not in a reactive system, what granularity I need to, or in a batch system or performance system, where the data locality resides? As in when am I using this thing? What data is relevant in that situation? Because in typical components, I'll be loading everything that is in a component in memory line, and the cache line. And that needs to be as minimal as possible. So I'm not pushing other things out of the cache line.

Anne van Ede  52:04  
You split it up when you realize that you don't use everything, or it needs to be used in multiple places. That correct? Like that is the one you said with data locality you dont use everything.

Gijs-Jan Roelofs  52:22  
Yeah, yeah, I think the the other thing that I need to state is that I try not to let a component to find the concept it's attached to. And then I shouldn't have a unit component. That's a bad design. Even if it were to follow if a unit is a concept. If you could express everything in your world in terms of components that's directly our classes, you could do that. That would be a very bad design, in my opinion.

Anne van Ede  52:53  
What do you mean with a unit components?

Gijs-Jan Roelofs  52:57  
Oh, sorry. Sorry. With unit, so that was an arbitrary like, combatant or dragon? Like, like a class name right?

Anne van Ede  53:05  
A component with everything of that unity. Yeah.

Gijs-Jan Roelofs  53:08  
Yeah. Sorry. Sorry. Sorry. Yeah. That, in my opinion, would be a bad design, because it doesn't take into account, can I easily change the composition of the entity? As an after I define this component? Am I going to be reusing it a lot? Or would breaking it up and, and defining it in terms of more generic component? Would that allow me to reuse those components? I position is a very generic concept. So that will probably be a separate component. Yeah, I think that's it,

Anne van Ede  53:52  
So you split it up, either because it's not all used or if you split it up, you can reuse it then?

Gijs-Jan Roelofs  54:00  
Yeah. 

Anne van Ede  54:02  
Okay. Then Then I fully understand that, your answer.

Gijs-Jan Roelofs  54:07  
Yeah. And for the reactive thing is, do I need to respond to a specific piece of a component? Right, that was the other aspect.

Anne van Ede  54:21  
Right. How do you make sure that, well you already showed that in the in the code with the trait archetypes, but how do you make sure that your component design is readable for other programmers? How do you keep it organized?

Gijs-Jan Roelofs  54:39  
Right. So we have, like I said, the central locations and these are, we have only a couple of them like four or five. And they are mostly based on context like ground combat as a context common is like very generic things. And then you have archetypes shared between ground combat and strategy. But then we also have, we have, he said, Where's the thing going? Trying to, Give me a second. Sorry, I couldn't find anything. Nothing. That's, P and G. Okay, well, this is awkward. Give me a sec because I need to. I did I did we disable it on this one? generator? documentation? What? Hey, where it's going? I feel like I'm taking crazy pills. Anyway, what I wanted to show you. And I'll probably look at that a later point, I'll try to find it because oh, yeah, fuck just one directory further Christ. Okay, there is a documentation lists of essentially all the archetypes that we have, and how they get reused and how their composition is, and for the basic primitives that we use within these archetypes. So for the common ones that are relatively flat, right, but I suspect that if we go to this one, the more interesting ones start popping up. Right? So what is the concept of an item? item has these components, right? Once it comes out of a corner corner, something that sits on the board, right? And is renderable, for example, and what components exists and what the ranges for those values are, and also what the links are between other entities, right. So you will have like, purple for groups and such but groups tags, you can also have links to other entities. So for a hierarchy of entities and such. So this archetypes, generating documentation, and mostly those two things. And then overall documentation that we have as well like a design document, but I can't show that.

Anne van Ede  58:07  
No, no, I can understand. No, but this is this is very interesting. I have to some point, you know, presents me the plan to generate so

Gijs-Jan Roelofs  58:25  
I can, here.

Anne van Ede  58:30  
Also the color codes and stuff, its a very good idea.

Gijs-Jan Roelofs  58:36  
Yeah, let me see if I have something that is more generic. Yeah. 

Anne van Ede  58:44  
The idea is clear.

Gijs-Jan Roelofs  58:47  
Yeah. So there's also a difference in how generic we go. Right. So you have renders generic, but corner is already a very concrete concept. Well, actually for this thing in this not because I is on the board a corner. Yeah. But you you catch the drift of the thing?

Anne van Ede  59:03  
Yeah. Yeah, that's okay. If you had to put it down to a few rules. The most important things to mind when you're creating components, what would those rules be?

Gijs-Jan Roelofs  59:25  
lifecycle, naming, reuse. I think those are the three, three biggest.

Anne van Ede  59:43  
Okay. And then I'm just going to skip a few questions. And as you say, naming what naming conventions do you use?

Gijs-Jan Roelofs  59:55  
Right. I'll just do it in terms of these. So we have certain very base types in our code base, a group is like sort of like an identifier. If you if the composition of an entity doesn't really uniquely identify the entity, as in, if the rest of its components are too generic to make it unique. And then the convention is just name and group, tag, if it's a single specific entity, like, let's say, the local player or the rendering camera, although in general, we don't want to reuse that too much. But it's again, name, tag, then we've got links, links are essentially relationships, one to one or one to many. And, again, name and then the link to have links, good example. Links are always they always have two sides. And they are auto updating. If you update one side of it, the other side gets updated as well. And we tend to do the naming of these links in pairs, right? Like you have, I don't know, what's it good. hangers and hangar, hanger hanger? Sorry. Like upgrades and upgrades owner, work side link and I don't know, what's the other one personnel slots link. These are not the best, constructor and constructing, for example, right, but they always end in link. So the the last part of the name is driven by the primitive that we use to design with. And that can be range as well, if it's specifically a range. And if nothing else holds, we end with component, although I have to say we've been lacks a bit sometimes with those things. And I might relax that in the long run as well.

Anne van Ede  1:02:04  
So you have very specific endings in the names, very specific suffixes to show that these are components, and these are more specific types of components. Do you have something similar for systems?

Gijs-Jan Roelofs  1:02:23  
No, no, actually, we don't. Well, we have no, actually I said, We don't, but we actually do. We have certain basic designs that we use. We have a state management system that handles the UI, and that will be called the UI state system. Right. And that will be generic. And that'll have several versions. And they'll all be called UI system at the end of it. We have the same thing for logic, right? Where logic system is the suffix there. For others? I don't think so. No, I don't. I think if if I think it's mostly common OOP naming patterns, right? Because there can be inheritance on the system. 

Anne van Ede  1:03:27  
Okay. Right. You say that your system is wrapped around unitys ECS.

Gijs-Jan Roelofs  1:03:45  
It's not unity ECS. Because when we started, we didn't have access to that yet. Essentially, what we've done is almost all the code is in our framework. And we use unity more or less as sort of a rendering engine. As in, can I start that up? I don't know, I can start that. And you can keep talking in the backdrop. But essentially, the entity world lives alongside unity. And it uses unity as a visualization layer as a sort of a model-view kind of thing.

Anne van Ede  1:04:20  
Okay, then you still use archetypes. And also in the same way as unity does. So for the class night, do you also use that for your implementation of a itterating offices.

Gijs-Jan Roelofs  1:04:41  
Is that a question or a statement?

Anne van Ede  1:04:43  
No it was a question.

Gijs-Jan Roelofs  1:04:45  
No, no, no, no, no. No, not in the same sense. I think, at least. This has also been a point of confusion between me and Sander when trying to talk about this. archetpe in the unity sense is all components on the entity, right? It is a you an entity is a single archetype. And in our model is a unity. An entity can be multiple archetypes. And by convention, it can be probably one class archetype, a multiple trait archetypes, and probably multiple state archetypes.

Anne van Ede  1:05:26  
No what I mean is unity uses. This is why I'm asking these questions is because unity uses archetypes for the way it stores its components. For example, the c++ ENTT library uses sparse sets to store components. And each of these implementations has advantages and disadvantages. So I'm trying to figure out what kind of underlying implementation you use to store your components and search through them. So I know how to ask the next question. 

Gijs-Jan Roelofs  1:06:02  
Okay. Okay, so this is, again, a loaded question, but I'll try to keep it brief. At the moment, we use a bit set sort of like sparse set approach, a combination of two. I think that both models are outdated, though, I think the future lies in a approach where a runtime measurement is taken, of how components of how entities are set up and used. And you can start looking at what component types are called as and not changed, much not updated much or added or removed, which ones are hot, and define your archetypes around that. And the model that I'm now trying to implement is one that allows multiple archetypes and optionally associated sparse sets.

Anne van Ede  1:06:58  
So, you for your current bit set/sparse sets are the things you avoid because of that implementation?

Gijs-Jan Roelofs  1:07:08  
Sorry, what was the last bit?

Anne van Ede  1:07:12  
because your current implementation, the current implementation, you use bit set/sparse set? Yeah. And what kind of things do you avoid doing because of the because of the limitation?

Gijs-Jan Roelofs  1:07:29  
Right, okay. ECS, UCSes has archetype approach, the problem there is adding and removing components from it is relatively heavy. And the idea being that with, that bit sets, sparse set implementation is that adding and removing is a lot cheaper. The problem, well, sorry, it's a lot cheaper. And we use that a lot within reactive design, rather than reactive design, you're constantly adding and removing components. So that's the choice that was made there. The downside of it is that the bitset approach is an older approach, older than archetypes, or sparse sets. And it is a very sparse component matrix, essentially. And the problem is, then your batches have a lot of gaps, right? If they're iterating, through an array, and we selectively apply sparse sets, on top of that, for the cases that we really need the performance. The reason why we haven't changed that more is that the cases where we needed to optimize have been few. And most of them bottlenecked, by the archetype approach in the reactive design, because the primary domain that we now implement a turn based game doesn't need the batching approach for performance as often as other domains.

Anne van Ede  1:09:10  
Yeah, basically, you find problems with archetypes, and that's why you use sparse sets/bit sets. Is there also a downside to bit set/spares sets that you avoid? Or that you, or maybe it's not that much of a problem for you, but something you have to keep in mind?

Gijs-Jan Roelofs  1:09:31  
Yeah, so bit sets the, like I said, it's a sparse component matrix. So you don't have contiguous arrays, which for batching is a real problem. But we've alleviated that by selectively stepping outside the component matrix and having it stored in a sparse set, as in our implementation allows us to choose the storage per component type. So we swap between those when necessary. 

Anne van Ede  1:10:02  
Okay. Is there something that I should absolutely avoid when designing specifically for components in this case? So when I decide how to split up or combine my components is there something I should absolutely avoid?

Gijs-Jan Roelofs  1:10:27  
I guess I think I haven't really talked about multi threading. Because the rest I think I've somewhat answered. I'm trying to really give you, trying to think of a good answer. The, the problem is normally, I would say, like, it depends on your use case, I can't like give a really hard reason, because I found that almost all rules that were set up around ECS, as they've been told to me, you can break if the circumstances are right. And, and I know that's a shitty answer for you. It's a it's a completely shit answer. But um,

Anne van Ede  1:11:23  
So I suppose in that way, you could say that the thing I should absolutely avoid is writing off certain things up front?

Gijs-Jan Roelofs  1:11:33  
Yeah, I guess, be open, be open about what you can do. Because what you can do with ECS hasn't been fully explored. And someone saying you shouldn't do this, and you shouldn't do that is going to limit how you can approach the design. And I guess a good design philosophy is still to keep your components minimal. And ideally, data only, if you start using the components as sort of systems of themselves. There are quite some corner cases to that. But even that can still be done.

Anne van Ede  1:12:19  
Okay. Then my next question. I have a question before I can answer ask the question. Have you ever converted an existing object oriented code base or parts to ECS?

Gijs-Jan Roelofs  1:12:44  
I think once maybe half half. The problem is that, like the strenght ECS, has adaptability in changes in design. I think I think. And the problem is that if a solution already exists, then the choice of employing or applying ECS, is can I take the time to read through all of this, just so that further iterations go quicker? And that is a very harsh proposition to make right. I've avoided the question. Right, could you could you pose a question again, it's just so?

Anne van Ede  1:13:47  
The reason I'm asking this, maybe that can help you answer. The the company I'm at has a large code base, and they would most definitely benefit from the design iteration possibilities, but also the performance but also the, hopefully, the code base, because it's a mess right now. So in many, many ways, they can benefit very much from going to ECS, but it's a very large code base. So the question, the next questions are, how would you approach converting that code base and what steps would you do it? But if you've never converted a code base, those questions are moot. 

Gijs-Jan Roelofs  1:14:35  
No, no, I've, I have ideas on I've partially done it. The primary point of entry I would have is find the most clearest application of ECS where the design philosophy comes across as a shining star, right, like physics is a very good example of that and implement ECS for that, and have have it as a as a context with its own lifecycle running inside the program, like a sort of like almost like a microservice approach where you set up ECS as something that you can query against and operate against. And then you start expanding, right, you slowly start converting pre existing code into ECS, but primarily show the strength of ECS by implementing the new features into it, right. And if you if you pick a framework that is novice friendly, right, doesn't bring a lot of bureaucracy to it. And if you pay attention to minimizing the bureaucracy, then ongoing development and developers will see that the disparity between maintaining the old code base and adopting new features into it and you get this gradual conversion. The other problem with ECS is that most of the designs in ECS, that are mature, tend to be very specific use cases, right, like the game simulation, as it were, and the areas that live outside that are less well defined. And the thing is that if you start with that approach iteratively, because that's what ECS should allow you to do. Then, all developers can also get acquainted with it without being confronted immediately with the entire thing. Right.

Anne van Ede  1:16:38  
I also like how you said that you should start with something that brings, immediately shows the advantages of ECS, like The physics is, like, Oh, we can do this in this way. And it works. And everyone's like, Oh, this is so nice. We want to continue doing this. That's also a mindset thing. That's very good advice.

Gijs-Jan Roelofs  1:17:04  
No, I, I think a very, very good way of working with other developers is not necessarily overload them with documentation and requirements, is but to give a very clear, well defined example of how they can do things and make that very easy to work with. And they will follow a pattern. So someone in a void, if shown a pattern will follow that pattern. Right? Yeah. So you can organically let them expand, right. And it works well for juniors as well. So that.

Anne van Ede  1:17:48  
Okay, actually already answered your question. Um, then I'm basically I'm down to my last few questions, like more of a wrap up question. Is there anything that you think is important for ECS design? That I haven't mentioned yet? Or ask about?

Gijs-Jan Roelofs  1:18:20  
I think relationships between entities, I guess, is a big thing. I'm saying that because I'm also working on a framework. But it's the problem is that like, it's, it's rather straightforward to, to, to define something that is a single thing. But how to maintain the relationship between those other things is not as well defined in ECS. Like we think five, six years ago, already, we define these links. And there are some benefits to that. But it's not really solid on how to approach that. Especially if you're going to be converting pre existing code bases, because a normal OOP structure tends to very heavily refer to other structures, right. It doesn't live in isolation as much. What other questions?

Anne van Ede  1:19:27  
Just to make sure. We say links in this case, you're talking about like a car having wheels, right? 

Gijs-Jan Roelofs  1:19:36  
For example, yeah. 

Anne van Ede  1:19:38  
There are multiple kinds of links just to make sure I.

Gijs-Jan Roelofs  1:19:42  
yeah, no, that's why I say just relationship we call them links, but general relationships and how they handle. I haven't heard you ask how to make a concrete conversion of certain OOP concepts. So I would probably explore that. A bit. 

Anne van Ede  1:20:00  
How do you mean that?

Gijs-Jan Roelofs  1:20:02  
Well, all P has very well defined patterns, right design patterns, like we have, we have classes, interfaces, yada, yada, yada. But we also have Christ, my God, why can't I just name a design pattern from the top of my head? Things like like builders, yada, yada yada decorators. All of these don't have clear designs yet, in ECS, how do I implement this concept, I can think of on the spot of a way to do this, but it's not standardized yet. And if you want to automate that conversion, then that is a definite thing that you need to deal with. Also ECS at the moment is set up very much in the sense of you have a global world and you have systems and they operate on everything in that world. And within an OOP setup, things are more compartmentalized, right? At this point in the lifecycle in your code base, you're dealing with these types of things. And this is that lifecycle, and at this point with these types of things. How do you do that mapping? is a good question, right? For example, if you have a simulation in a game, and you need to disable certain entities from not simulating because you're not in that region of the world anymore, how do you deal with those concepts? Because in ECS, it's very easy to say everything that has a position and a physics component needs to update, but the problem is if you define it in terms of that you have not defined the terms under which it should not operate, but still exist. And that lifecycle is not something people are talking about explicitly. Right? So how to do that is a definite

Anne van Ede  1:22:10  
Like I've said this to other people, too, but every time I have an interview, my future research section goes longer longer. This is so interesting. Yeah, you're absolutely right. But this is so far out of the scope of my research.

Gijs-Jan Roelofs  1:22:27  
Yeah, no, I know. I know. I know. I know. Hey,

Anne van Ede  1:22:30  
I wish I had time for everything but unfortunately.

Gijs-Jan Roelofs  1:22:35  
Oh no, no, I definitely.

Anne van Ede  1:22:37  
I actually want to graduated at some point.

Gijs-Jan Roelofs  1:22:41  
I finished Maastricht University under an AI course right you're doing Utrecht right Yeah. Like you have still you've got USIKI Incognito over there right I think.

Sorry wat?

De studentenvereniging Incognito, dacht ik

Zegt me niks

Oh okay, oh wacht sorry die hebben een heleboel.

Anne van Ede  1:23:05  
A-Eskwadraat ken ik wel en Sticky ook, dat zijn de twee Informatica en ict general, maar.

Gijs-Jan Roelofs  1:23:13  
In kennistechnologie zitten zij, denk ik, heet het. Moet even kijken, of ik hier. Maakt niet uit in iedergeval. Anyway, maar ik ken je probleem. En ik denk ook dat het heel belangrijk is dat je je gewoon limit en dat je dit gewoon allemaal onder future work zet en klaar. Want alleen dat heeft al waarde. Ja ik, even switchen naar het Nederlands. 

Anne van Ede  1:23:38  
Maakt niet uit. Maar ik zie dat het al bijna tijd is voor jou. Dus ik heb nog drie korte vragemn. n, heb je nog mensen die, waarvan jij denkt dat ik met ze moet praten?

Gijs-Jan Roelofs  1:23:58  
Een heel ander perspectief, geeft, heb ik laatst zien opkomen onder de, iemand die heeft Boby. Ik moet even een link van hem opsturen. En die lijkt ontvankelijk te zijn aan vragen die naar hem worden gesteld. Hij is een industry veteraan, die enigzins nieuw met ECS is en een heel erg pragmatische blik heeft. Waar ik het heel vaak niet mee eens ben. Maar dat is juist een een interessant perspectief voor jouw misschien. 

Anne van Ede  1:24:27  
Ja.

Gijs-Jan Roelofs  1:24:30  
Hij kampt veel met junior developers en de problematiek daaromheen. Dus waarschijnlijk kan hij je daar wat inzicht in geven. Ja goed, ik heb het gevoel dat, wie heb je allemaal al gesproken? Is misschien een betere vraag.

Anne van Ede  1:24:43  
Nou ik zie Sander ertussen staan. Ik zie Carter ertussen staan, die ben ik nog aan het stalken. Rast0r, die wil ik ook nog gaan stalken. Ik heb dus diegene van ENTT, Svelto.ECS en nog een paar gasten ook gesproken. Met unity ben ik ook in gesprek. Maar, zegmaar, als jij iemand denkt, oh die moet je spreken, oh Sebas inderdaad die heb ik gesproken.

Gijs-Jan Roelofs  1:25:16  
Ja Sebas van, Svelto is een interessant figuur. 

Anne van Ede  1:25:18  
Ja, hij heeft een geschreven versie terug gestuurd. Hij wilde geen interview inplannen. 

Gijs-Jan Roelofs  1:25:28  
Hij is Italiaans dus zijn Engels is niet zo geweldig. Tenminste, ik dacht dat hij Italiaans, ik weet het even niet zeker. 

Anne van Ede  1:25:32  
Ja, hij is Italiaans. 

Gijs-Jan Roelofs  1:25:34  
ENTT van de maker van ENTT, die heb je ook gesproken? 

Anne van Ede  1:25:36  
Bedoel je zegmaar, E N T T? 

Gijs-Jan Roelofs  1:25:39  
Ja. 

Anne van Ede  1:25:39  
Ja, die heb ik gesproken. Ik wist niet dat ze een discord hadden ENTT

Gijs-Jan Roelofs  1:25:40  
Ja, ja ja, Bevy dat was Cart. Dit is allemaal de heel moderne frameworks. Even kijken. XE, wie moeten we hier hebben. We hebben trouwens ook net een een discord server opgezet rondom het beter definieren wat ECS nou daadwerkelijk is. The ECS Guild. Ik weet niet, heb je daar een link naar?

Anne van Ede  1:25:48  
Nee.

Gijs-Jan Roelofs  1:25:54  
Dat is echt letterlijk de afgelopen week geweest. We zijn aan, wat we willen doen we willen de taal gaan unifyen, over hoe je praat over ECS. En ik denk dat al jou werk trouwens ook heel valuable daar is. Maar dit is echt letterlijk net begonnen. Ik ben even aanhet kijken of die. Maxim.

Anne van Ede  1:26:19  
Die heb ik inderdaad ook door gekregen van iemand van, eh die moet je gaan spreken.

Gijs-Jan Roelofs  1:26:17  
Ja maar Maxim, Maxim is een beetje een achtergrond figuur geweest op de ontwikkeling van Entitas. Ja, ik probeer even na te denken wie verder nog interessantere views geven, maar ik denk, maar goed hij is ook vrij goede developers dus je kan hem gewoon, op zijn minst kun je hem pingen. Wie hebben we hier nog? De ECS Lab daar kan ik je ook wel in sneaken. Oh daar zit je al in. Okay, dan weet je wel de usual suspects, die hier rondhangen, zijn vooral allemaal interessant. Voornamlijk denk ik ook VBlanco, Ik denk dat die misschien nog wel wat interessants te zeggen heeft. Er is nog een ander nederlander die, Daan van Ieperen. Ik weet niet of je contact met hem kunt krijgen uberhaupt. 

Ik ben rederlijk goed geworden in stalken, dus.  

Is dat hem, ja dat is hem. Okay, Daan on Github. Hij heeft, hij is een van de core contributors van Artemis odb en hij heeft echt een hele lijst van van kleine games gemaakt met ECS. Dus hij heeft er heel veel praktijk ervaring mee. Ja het grote probleem is dat, ik zou de maker van Artemis odb ook aanraden maar, die daar zijn we een beetje achteraan aan het gaan, want die is een beetje van de aardbodem verdwenen lijkt het. Das een beetje naar. Fuck. Even kijken. Maar hij is wel heel erg aardig, Junkdog, heet hij. Dat is van dat, maar ik denk niet dat je hem te pakken krijgt. Weet ik niet helemaal zeker. Ja hij, Adriaan Papari. Maar hij is ook al, hij is al een tijd niet meer online geweest, ik weet niet wat er met hem gebeurd is. Ja Unity, is dat Joachim Ante, dacht ik. Ante, heet hij zo? Ja, hem. Ik denk dat je hem, wel contact met hem kan opnemen. Ja Sander heb je al gesproken mee. Even nadenken. Ik ben echt mensen aan het vergeten. Trouwens deze lijst is ook echt niet representatief voor, daarvoor. Want er zitten ook een heleboel mensen bij die adhoc een keer een bericht hebben gestuurd ofzo. En ik zit niet vaak echt hier op Discord.

Anne van Ede  1:29:42  
Nou als je nog mensen later bedenkt, dan... Ik ben al heel blij met deze lijst die je nu gestuurd heb, dan kan ik inderdaad ook verder. 

Gijs-Jan Roelofs  1:29:53  
Ja ik zou ook misschien vanuit de ECS guild, want ik heb die Discord opgericht. Je mag van mij gewoon echt die vraag stellen, in discussion. Gewoon zeggen van he, ik ben op zoek naar die mensen, naar mensen die er of mee bezig zijn of er ervaring mee hebben. Neem contact met me op. Rast0r is redelijk nieuw ermee. Dus die gaat ook wel een interessant perspectief geven. De rest weet ik even niet. Skypjack! Oh hij zit er toch op. Ja dat is de maker van, die is van ENTT. 

Anne van Ede  1:30:23  
Ja.

Gijs-Jan Roelofs  1:30:27  
Ja, maar hij heeft wel een heel uitgesproken visie. Ik ben wel, ik ben wel heel erg geint, ah dat is wel jammer dat we dat niet kunnen delen. Ik zou wel heel geinteresseerd zijn in de antwoorden van anderen. 

Anne van Ede  1:30:40  
Ik wil sowieso ergens wel, sowieso in mijn thesis, maar ik wilde eigenlijk ook nog ergens anders een keer een samenvatting maken van alle visies, zegmaar, wat uitgebreider dan in mijn thesis kan.

Gijs-Jan Roelofs  1:30:54  
Ja.

Anne van Ede  1:30:55  
Is denk ik wel heel erg nuttig en interessant om te kijken hoe andere mensen erin staan. 

Gijs-Jan Roelofs  1:31:01  
Ja, ja. Ik ben trouwens ook heel erg geintereseerd in the tool, als je daar hulp bij nodig heb of dergelijke, dan mag je gewoon contact met mij opnemen. Als je verdere vragen hebt ook. Ik had niet kunnen reageren, ik had gezegd namelijk dat ik zou reageren op je eerdere vragen al voordat we het interview hadden, maar dat kon niet, want ik had een technical due diligence deze week. En ik had gewoon de tijd niet. 

Anne van Ede  1:31:23  
Dan heb ik nog n korte vraag voordat je weggaat, mag ik je toevoegen op LinkedIn?

Gijs-Jan Roelofs  1:31:27  
Sure. 

Anne van Ede  1:31:29  
En dan is de tijd op. Fijne dag nog.

Gijs-Jan Roelofs  1:31:37  
Yep, jij ook. Ik wens je heel veel success. Mijn LinkedIn is niet heel erg up to date though, dan weet je dat alvast.

Anne van Ede  1:31:43  
Maakt niet uit.

Gijs-Jan Roelofs  1:31:46  
Alright, alle success, hoi hoi.

Anne van Ede  1:31:51  
Doei. 

Gijs-Jan Roelofs  1:31:51  
Doei

Transcribed by https://otter.ai
