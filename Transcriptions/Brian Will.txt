Brian Will  2:20  
Oh hey, how are you?

Anne van Ede  2:23  
I'm good. How are you? 

Brian Will  2:25  
I'm fine. Thanks. I noticed Actually, let's see. Oh, no, I'm sorry. I supposed to say I might have a conflict at 11 but No, I don't. So I'm just curious, do we need 90 minutes necessarily?

Anne van Ede  2:38  
I won't. Most people are 90 minutes or two hours. So. Okay.

Brian Will  2:42  
Okay, that's good. Okay, just wanted to verify. So you already met with Fabrice.

Anne van Ede  2:49  
Yes.

Brian Will  2:51  
Okay. And you wanted to meet us separately, just to get more independent results? I guess. 

Anne van Ede  2:56  
Yeah. So I can, you know, compared with the rest of my results. Okay.

Brian Will  3:03  
Yeah, so I mean, I looked over the four questions, those. I just thought, I think four questions that you had, and Well, I mean, well, I assume you have more detailed questions?

Anne van Ede  3:14  
Yes. These are just the topics. 

Brian Will  3:16  
Okay. Okay. 

Anne van Ede  3:17  
Yeah, that's like the topic questions. And I got more specific questions to go with that. But shall I just start with my introduction. This right. So like I said, in my, in my text, I suppose, I am looking to create a tool to convert from object oriented to data oriented code. And I got interested in this two years ago, when I first found unity ECS. And I thought, Oh, this is super cool. But many of my fellow students and colleagues didn't want to go over it because they didn't know anything about it. And it was difficult, it was very different from the way they were taught, especially at the university is just object oriented. And I was wondering, why is there not something to help them? Especially if its a company that already has a large code base? Why is there not something to help them convert? So that's basically what I'm trying to do now. I'm creating a tool that takes the object oriented code and generates a plan for the new data oriented code, more specifically, entity component system code. It doesn't port the code itself, it just generates a plan for it. And

Brian Will  4:29  
Are you talking systems, or is it just the data side is it just entities and components?

Anne van Ede  4:33  
Its mostly the data side, but it does take the systems in into account. 

Brian Will  4:39  
Okay. 

Anne van Ede  4:40  
So at the same time, I want to educate them on why it's a good plan, and why so that they can maintain it and expanded if needed. But for that, I of course, need a good plan. And that's basically where you guys come in. I'm trying to ask as many people as possible on their opinions to find like a common denominator. and generate a objectively good plan and then maybe some options that they can customize it depending on which platform they use. So for that I created the interview, I've got a bunch of open questions around the topics that I sent. And I because I'm speaking to many different people from many different backgrounds, I created them quite open. And hopefully still specific enough. But if it doesn't suit your situation, because it was too specific, just tell me so and we can just ignore the question or change it or whatever. Like I said, we scheduled an hour and a half, but most people are between an hour and a half or two hours. So that also Would it be okay, if I use your name in my report if it needs to happen, so they know that I asked like legitimate people? 

Brian Will  5:48  
Okay, sure. Sure. 

Anne van Ede  5:50  
At the same way, I would like to record this strictly so I can type it out later. I wont spread it on the internet.

Brian Will  5:55  
Okay, sure. Sure.

Anne van Ede  5:56  
Okay. That'll make my life a little bit easier. Um, are there any questions you have for me before we get started? 

Brian Will  6:05  
I don't think so, no.

Anne van Ede  6:06  
Okay, then just some warming up questions. Can you tell me how you first got started with ECS or acquainted with ECS?

Brian Will  6:15  
Similar to you, I saw the initial announcements for for unity dots. Even before it was called dots andI was very interested in it, I actually had no experience with Unity at the time. And eventually, that led me to dabbling with Unity. And eventually, I started producing YouTube material, covering what I gathered from from playing around with it. And that eventually led to this job. So that's basically the story. So I have no industry experience making games. Number one, I have no industry experience using DOD. Though I was already doing some of it in the respect that I wasn't, I'd steer away from object oriented style. I was, I would say, I stick more to a procedural style, which, in my opinion, kind of naturally can lead you to doing elements of DOD, though not necessarily following all the prescriptions. Yeah, so that's sort of my my background. In, it was just, it was just how did you acquaint yourself with ECS, is that? Yeah, I mean, I do actually remember encountering the idea a couple times, just looking around the internet and people talking about game programming, but I'd never really delved into it until unity ECS came along.

Anne van Ede  7:39  
Okay, and can you tell me how you currently use or associated with ECS.

Brian Will  7:46  
So like Fabrice, I'm on the dots team. And he and I are primarily responsible for documentation, samples and training around dots. So he conducts the training we have these internal training sessions that are week long things that he conducts in Europe and I conducted in North America on zoom, of course, but you know, for for timezone reasons. It's split. Yeah. And so, myself, when I first joined unity a year ago, I first thing one of the things I did is take the training myself, and eventually then I assisted as a TA for a couple of the sessions and I took over as the the main person to do the lead of on it for the last five months or so. So, I, today, do nothave any expertise it's very recent, so. I'm not a veteran by any means. Yeah, that's mainly it.

Anne van Ede  8:44  
Okay, um, have you? Yeah, you're probably answered it already. But have you work with any other ECS implementation outside of unity?

Brian Will  8:54  
No, I'm not. I've not worked with any others. I'm passingly familiar with a couple But no, not worked with any.

Anne van Ede  9:03  
Okay. Can you tell me in one or two sentences the biggest advantage of ECS that you see?

Brian Will  9:14  
Separation of code and data. Do these necessarily have to be short sentences?

Anne van Ede  9:27  
It doesn't necessarily have to be two sentences. I spoke some Italian people and they will talk about 10 minutes for this. So that's how I change the question. 

Brian Will  9:35  
Okay. So,

I've been thinking about this recently is like, what is the difference with procedural programming, object oriented programming how is DOD different and most succinct explanation I came up with is that in procedural programming, the idea is the most important thing to write about your code is to properly decompose it into functions, aka procedures. And the idea is that if you get that right, if you do a good job, then you're Going to, it's gonna be easier to write your code in the first place for like a first draft or implementation, and it'll be easier to maintain and extend your code. That's the theory is like you get this. That was like the 60s and 80s.Then object oriented programming came along and said, No, you got to structure your code into units. We call objects to bundles of code and data together, and you decompose your problem into objects correctly. And that's going to solve your problems, that's gonna make it easier to write your first draft and to extend and maintain your code. And you have to figure out like how all the objects communicate, and all these theories about how your objects should be structured. data oriented design says, No, the code and structure itself is actually really not all that important at all, the first most important thing to get right is the data itself. You get that right, you think hard about what data you need, and how it should be structured, irrespective of code. And then you think about, well, what transformations does it need to undergo? And only Thirdly, do you think about the code. So the code is actually secondary and, you know, sure, of course, you're using functions and procedures, but you're, and you're, you might even use objects in some degree. Like you don't necessarily have to forsake the concept of encapsulated objects entirely. You're just not, you don't think that like, oh, decomposing the problem to objects is going to solve your problems. You think first in terms of the data, and the emphasis here, mainly because of Mike's influences, like yeah, of course, the emphasis is performance. And of course, it's very relevant for games to to solve your performance problems to have a good solution for performance. But for my emphasis, I actually think just an easier way to think about problems is just object oriented programming, thinking in terms of objects is very mystifying. And to abstract in a way that actually is makes it harder really to write code then, particularly after after, like the initial stages of your, of your project, like in the medium and long term, it actually is just a much harder way to reason about, about solving a problem. So So for me, it's actually the my emphasis is it's just an easier way to think.

Anne van Ede  11:54  
Okay, in the same way, can you say the biggest disadvantage you see of ECS?

Brian Will  12:00  
It probably, certainly in its current form with dots ECS. Getting off the ground. This learining curve, it's, it's, it's, it's unfamiliar to most people. So partly, it's just unfamiliarity. But also, there maybe is a little bit of a there's a little bit of a barrier to entry in terms of how much you need to learn to get off the ground. And also in a project, it might take a little. You can't just start throwing things together at the outset. I mean, not supposed to do that I'm trying to design but it's maybe it's harder to even do that at all in DOD, perhaps. As I'm saying, I'm not sure this is actually true. It's just what came to mind. Yeah, did. Yeah, there might be a little steeper learning curve at the outset of a project perhaps. That's my main takeaway.

Anne van Ede  12:56  
Also an unlearning curve for most programmers from object oriented, to a yeah.

Brian Will  13:03  
Yeah. Yeah.  Yeah, yes. It's partly an unfamiliarity thing of Yes, that a lot of people well, in Okay, actually here in ECS. In particular, with entities and components, it is not. entities and components, it is possible to do struct, uhm, hierarchical and order data. And just arbitrary graph, so like this entity references this entity or a set of node of entities, you can do that. But as soon as you do that, you're you're like losing the benefit of linear memory layout. And so people might feel guilty to do it. And also, if you do do it, it's not particularly convenient to work with, like, you're losing a lot of performance benefits. And also, it's not the most convenient way to work with hierarchical data or graph data, or things that are ordered, you won't have a list of things no matter what the order is. entities are, have no particular order, you have a bunch of entities in unity ECS, in particular archetype and there's no order to which one comes before the other. So that that is a weakness. And so the solution in dots is you have to, but you can fall back and use collections, you can just have data structures that are outside your, your entities and components. But then the question is, okay, do I should that just be a acceleration structure? That's like a copy of the authoritative data you have expressed in terms of entities and components? Or should it? Or in some cases, do you even make it? Do you have something outside of your entities and components that is authoritative data? Right, not just an acceleration structure, and that there's some open questions of what the best practices there are, the what the best practices are, are in that area. Did you get all that? 

Anne van Ede  13:20  
I yeah. 

Brian Will  14:18  
Okay, thanks.

Anne van Ede  14:54  
It's not the first interview I had. So it's a bunch of information thats stacking up on each other. So maybe in the first time, I wouldn't have been able to follow you, but right now I do. 

Brian Will  15:05  
Oh, okay. So someone has someone have a similar thought before?

Anne van Ede  15:10  
Yeah, actually quite a bit. Yeah.

Brian Will  15:12  
Okay, cool. Then it must be right.

Anne van Ede  15:17  
Exactly. So that's why I'm collecting as many opinions as possible to see if there's like, many people agree. Also on the advantage part, like, performance is nice, but it's not the main thing. It's the flexibility and the way of thinking that's really, the biggest advantage for most people.

Brian Will  15:35  
Actually remind me was the question now  DOD or ECS? Not exactly sure. 

Anne van Ede  15:39  
ECS

Brian Will  15:39  
Okay. Yes.

Anne van Ede  15:41  
Yeah. Right. So the next questions,

Brian Will  15:45  
I may have sort of mixed that in my head a bit when I answered the questions. So

Anne van Ede  15:49  
that's okay. Um, even if it's not necessarily useful for my research, it's still useful information. Like for me, I don't mind.

For the next questions. There's two things that I wanted to mention before we start. One, please explain it to me like, I'm five, because what you might think is so obvious that you don't say it? Because, I mean, that's you, that's obvious. It might be exactly what I still need to know. And second, these questions, and like the previous ones are to gather information not to, you know, answer the question exactly as it's meant. So when you mixed it up in a previous question, that's okay. Because I'm looking for the knowledge that's inside your head. And not specifically the answers to the questions I asked me questions are just a way to get the information out of you.

Brian Will  16:41  
I had a thought about the previous question, I can make a little addendum, you asked, What are the advantages of ECS? And I didn't mention flexibility. ECS is a good the way Mike put it to me, it's a good default, its neccesarliy the optimal way of structuring any possible data. There's no such thing as a universal data structure that's ideal for everything. But it's a good default. And so even in your if your project, it turns out down the road, you want to optimize and, and really hone things, you might move away from everything being in terms of entities and components. But it's a good way to start. Because splitting things into separate components and the way you can just glomp components together on entities can be quite flexible. So that was my thought there. Sorry.

Anne van Ede  16:41  
That's okay. Please, if you have further thoughts down the line, just

Brian Will  17:32  
I just realized that Yeah, I was talking more about DODthan ECS. And so

Anne van Ede  17:37  
that's okay. For the next questions are like in four different categories. The ones I send you, General ECS design, more specifically, component design, code base, large code base and code conversion and coding and naming conventions. There's some overlap there. Just that if a previous question doesn't get the answer, next question, does kind of, we got skipped some if necessary. Right, so when you're making an ECS design, whether it's for training or for yourself, can you walk me through the steps that you teach? Or do yourself to make an ECS design?

Brian Will  18:18  
Okay, what we teach is we have just the spreadsheet, we just have an example that we show them of here's the simple breakout game that's been decomposed into components. And for each components, the questions are, what what type is it? Of course, what's in the component? Let's see. How frequently does it need to be modified? How frequently is it going to be read? How many instances are there of this thing? Is it just like a one off where there's only one, one instance? Or there are many? What else we ask? We ask, Yeah, and the interesting part is actually start out and think just in terms of components, instead of thinking about the entities together, we don't necessarily think about, oh, this component goes with this one. That actually, interestingly, tends to be deferred to later. So just think about the components first, individually. Have you asked about systems yet? Or are you just talking about components?

Anne van Ede  19:21  
This is the whole design so systems as well.

Brian Will  19:23  
Right. Okay. So once you figure out your components are and just you've answered basic questions, like how frequently does  the state occur, how frequently does it change, and how frequently is it accessed? Then the question is what data transmissions you need to undergo basically, what systems do you need? And so the next part of the spreadsheet is okay, now what just lists all the data transmissions you need? What data are they going to touch? What do they need to read? What do they need to write each one? And how frequently What else is there? I'd have to look at the spreadsheet but that's the gist of it is just work it out on a doesn't have to be a spreadsheet but that's just We use just basically we'll list individual components, lists your data transformations, aka systems. And what are the most essential things you need to know about them, particularly frequency is a big part.

Anne van Ede  20:13  
So you don't look at entities at all. So you first just like, okay, there needs to be a rendering component and a moving component and a an AI component. And then later you decide on which well objects, like the player or the enemy, need what components? Is that the order in which you go?

Brian Will  20:35  
Yeah, that's what we've been doing. We've been wondering if this, if not explicitly covering how the components get grouped together on entities, basically what archetypes you have, whether that's maybe something we should try doing? I think it isn't, I think it is a good idea to start with just components by themselves, because it then tends to be more, if you're thinking in separate entities, you'll have like your position component, look at what you're not sending an XY coordinate or something. And if you start thinking about entities too soon, you might not recognize a commonality of Oh, this thing over here has an XY position, this thing also over here is an XY position. They don't need to be separate components, they just do one thing. And so if you just think in terms of components, it gonna be easier to identify, oh, these two components, they're really just the same thing. They don't need to be separate kinds. There used to be one type, and then we'll look, later on we'll decide, oh, these two different archetypes use the same component. And what distinguishes them is the separate archetypes, we don't need to have separate components. And so there's no, maybe a bit far ahead. But the interesting thing to me is that intuitively, we don't we avoid thing in terms of abstractions at the code level. But I think you might say the data level, the emphasis actually might be on abstracting at the data level in terms of finding the general case, like finding the commonalities of Oh, the same piece of data is used in many different contexts. And so if you abstract the data level, it's maybe arguable as to how the term extraction is appropriate here, but it kind of makes sense to me. If you find a commonalities at data level, that that is the place to start in terms of abstraction, of solving for the general case. It's interesting because in duty, there's I think, then there's this tension of the explicit, you're told not to solve the general case, you're told to solve your specific problem. On the other hand, you don't want to have like, oh, here's a, in a game on my you have a here's a, here's a monster position. And here's a player position, you don't want those to be separate things, you want them to basically do the same thing in most cases. So that's the interesting thing to me. I'm sorry, what is the original question?

Anne van Ede  22:42  
you're answering it perfectly. Okay. Yeah, indeed, the, the way you're thinking about data, one person, he said that he likes to put like every what would be like archetypes then next to each other, or, you know, he goes from object oriented to data oriented, for object oriented programmers, so to help them and he says, first put all the like the an orc or a player character and everything, put it side by side, and underneath it list every data type that it contains, and see where there's commonalities.

Brian Will  23:16  
Right, I think that's probably totally legitimate. I don't know if it's necessary to put objects entirely out of your mind and think put entities and archetypes out of your mind entirely. It's just how we've done it so far. And maybe Yeah, I don't know. Well, I think we should probably experiment with thinking more explicitly about archetypes in the upfront design.

Anne van Ede  23:40  
Okay, um, when you started with ECS what was the biggest misconception you had?

Brian Will  23:51  
Oh, geez. I really can't think of anything, there probably was something quite early on.

Anne van Ede  24:13  
Something you thought would work or would help and then it turned out it didn't?

Brian Will  24:26  
I can think of. Yeah, I can't think of anything which is not to say my my my understanding was immediately perfect at all, but I just don't remember any specific misconception.

Anne van Ede  24:43  
That's okay. Right. Can you tell me something to avoid when you make an ECS design?

Brian Will  24:52  
Something to avoid?

Anne van Ede  24:55  
Like a no go?

Brian Will  24:58  
Yeah. Do you mind if is it cheating? If I look at my own notes?

Anne van Ede  25:04  
No, that's okay. 

Brian Will  25:06  
Okay. We have this, these tips we've put together recently. Like no go, don't things not to do at all. Okay. It's a debatable point of whether your components should have methods at all. even smaller, small, like little accessor methods, it's just a really simple thing of like, oh, there's this common math formula when you access an X, Y position component. And you want to put a little vector operation on something just because it's convenient, and generally our thinking is just avoid that entirely. There's that you don't want even start down that not necessarily, because even small excesses are harmful. It's just you don't want to start down that road. So almost always, we told them just don't put anything on your components period. I think there might also be an issue with some to do with burst compilation where it may not effectively there was some issue that I can't recall at the time, but it had to do with how burst might not effectively optimize those calls, I think, could be totally wrong. So that's one no go is don't put code on your components. What was an actual no go? Yeah. Yeah, no, no, these tips, they're not like, never do something. And yeah, that's more tendencies things like, maybe we'll get there. But in general, favor smaller components, in general, like favorite splitting them up. But it's not really it's not a hard rule. There are cases where it's actually fine to have a component with many fields, because maybe like, there's only one instance of it. Yeah, but that's not a hard rule. Oh, okay. There's another not an entirely hard rule. But in almost always, you want to avoid putting data in your systems. You can have private fields, because maybe it's something that's only used in that system. And it's just convenient to put it there. But what what'll happen is like, oh, it turns out, I need that data in some other system. And then you just do the simple thing of Oh, make it public. And this other system is grabbing this other system and grabbing its public field. And virtually always, you should put that data in acomponent in one form or another. And that can be a problem, because the restriction with components is that they they can't be, well, regular components have to be unmanaged. And so you can't put anything managed in them. You can't put collections on them. But you can have a managed component now. So that's, that's one solution of it, for the case of like, Oh, I just wanna have this big array. And I use it in these two systems. If, if you put on one system, then one thing I find I really don't like about that is that it's, you know, it's saying that the codes, the data somehow belongs more to the system than the other one. And often is usually in a very arbitrary way. And so what's nice about ECS is you can, the data can be off elsewhere, the code and the data can be split. And you don't have to think about like what data belongs to what code, you don't have to think in those terms. And also, there's the in terms of the details of our API gets, it gets messy when you have to have systems grab data from other systems. It's there's just a lot of problems with it. So that's maybe not a hard, hard rule, but it's it's close to one. 

Anne van Ede  29:12  
Okay. Right, then we're at the end of the general ECS design questions. We're going to the more specific components design questions. Like I said, there's some overlap, but sometimes there's something that people don't mention in the first time and then they mentioned it a second time. When creating components, how do you decide how to split up data into different components?

Brian Will  29:43  
Well, this may be an application detail of dots ECS is that generally you want bursts to be able to properly vectorize your code. And to do that, generally, you have to have a single field per component. So that's a big reason to strongly favor single field components for anything that's has many instances, anything that's, you know, large data and many occurrences. If it's just a singleton, and it's accessed infrequently, you know, not not a problem, you can just dump a bunch of stuff in there. And in fact, that's really, you know, I would generally favor that for like some kind of like setup data. Instead of having a bunch of separate components, I would say, just, there's no reason not to just glom it all together in one place. When it when it seems convenient. Otherwise, you strongly favor single components, probably for burst reasons, also, for flexibility reasons, because you'll find, as things change, oh, turns out, you know, I thought I was assuming upfront that A and B are used together. So I put them in the same component, because I tend to use them always together, bunches of these cases are Oh, no over here using A without B, and vice versa over here using B without A. And so it's just better to certainly start with things being split up. And you might consolidate later in a project, you might decide, oh, these things are always used together. And maybe you'd really have to experiment to figure this out. But there might be cases where, at a certain point, you know, there's a provenance problem to have a query where you're going over, you're looking for archetypes that, that you're going over chunks, and you're accessing like eight or more components at a time, because of a certain point, you start triggering cache issues, you know, it's not, at a certain point that the processor can't access a bunch of parallel arrays efficiently. So there might be cases. I mean, generally, that's generally thats the smell of you've made some design problems, you know, maybe there are better alternatives in those cases to begin with. But that's one reason you might want to start consolidating is it's actually you're losing cache efficiency, potentially. I don't take my word on that. I'm not authority on that. But that's my understanding. So the original question just, what, what guidelines to use to decide?

Anne van Ede  32:16  
Yeah, you split it up?

Brian Will  32:18  
Yeah. When in doubt, split things up, basically. And then we have a solution for the case of like, Oh, I need an X and a Y, we have a float2. And that's considered, burst is smart about that is it recognizes that as a single thing, I can vectorize that. So. So it's not necessarily just like one scalar value, but it's almost always one field? I guess, I guess that's my answer.

Anne van Ede  32:44  
Okay. And then how do you keep it like readable or organized for any other developers? Like, when you have a ton of components? Because everything has just one value? How do you make sure that the rest still understands it?

Unknown Speaker  32:59  
Yeah, that does get to the problem of what you often want to know when you come to an ECS project is what are the archetypes? And right now our tools that there's nothing in the code that necessarily declares what the archetypes are, like? How are these things grouped together? It's kind of it's partially implied from the queries of like, oh, you're accessing foo and bar together. So there must be one or two entities that have foods and bars, probably. But it doesn't necessarily tell you what else those entities have. And they're not necessarily just one archetype, it could be many archetypes have foo and bar, right. And then, but then in the I think, the eventual idea, hopefully, what will happen is the editor tools, you can run your game and inspect and see what archetypes you have, that that's one solution that's kind of in place already is there. There's ways to inspect what archetypes exist. But it's not. I dont know, I think there's work to do there in terms of UX of just exposing to the user what archetypes are in their code, and how frequently they occur, and that sort of thing. There's also just kind of a practical code problem of unfortunately, what you want to do with most components, or, I mean, most components, you want to automatically generate an authoring component. And we have the general authoring component attribute. That right now the way it works, it requires the class be, the the struct to be the only struct in the file. So you have to very annoyingly split your components across separate files, which I really hate. When I've worked in other languages, I always like to like when I used Go, I put all my structs in one file, typically, it'd be nice to be able to do that eventually that should be fixed. So that is one solution is just putting all the components in one file if you can. I there more to the question I think, I don't know if I answered the question.

Anne van Ede  34:57  
So, you say when I want to keep it organized for the rest, I keep the archetypes organized and not the components?

Brian Will  35:07  
Yeah, I think the archetypes are maybe more of the problem. I suppose that a really large project, maybe people will absent mindedly create components that are redundant with others. But that's that's sort of it's just a data design problem of making sure that you're, you're really looking at your data closely. Hello. I actually don't have much experience with really large scale projects, we've mostly worked with very small thing. Small, yeah, small scale.

Anne van Ede  35:37  
Okay. I'm going back to the the the first question I had about splitting up data. When would you decide to combine two components?

Brian Will  35:50  
Yeah, basically, is a case of a singletons of just like this is just initialization data, probably, or something accessed very infrequently. And it's just convenient to group these things together. Because they're usually used together and the performance doesn't matter in their case. That's one reason. Another reason is, yeah, I think I may have covered it just you have some queries that are accessing in parallel to many separate component arrays at once. And at a certain point, depending on the hardware, you're you're, you're losing cache friendliness. And so you might want to consolidate in those cases. But then the trade off is you're losing, in many cases, you're losing vectorization from burst. So that's, it's just something if you're doing it for performance, you really have to measure it, you have to be very careful of is this actually a win? I would say. And I can't actually point to too many examples where I know definitively it is paid off to consolidate. So maybe I'm totally wrong. I don't know if that's actually it's something in practice you would do often at all, if ever. So I guess my answer is if they're not Singleton's, you generally just keep them separate. If they're not like, one offs, you probably would just keep them separate, I believe.

Anne van Ede  37:22  
Okay. Maybe this question is not really applicable for you, but do consider low level stuff like read-write separation, hot-cold separation, or cache alignment?

Brian Will  37:35  
Rad-write separation? Yes. Yeah. But that usually just follows from splitting things into individual components. Though, I suppose based on archetypes, you might have some, you know, a bunch of different archetypes that will have a foo and then yeah, you might want to design your queries carefully so that you can split the hot and cold archetypes, I guess. So the answers sort of a little bit, but probably, I guess I don't really care about it too much. 

Anne van Ede  38:22  
Okay. Right, if you had to put it down to like, a few basic rules that you can teach others, for example, what would those rules be when you're creating components?

Brian Will  38:42  
Creating components. Let's see. Yeah, as we've discussed, generally, strongly favor, one, one field per components. I do is actually one case where you would break that rule actually now is when you have entities that reference other entities, when a component has entity references there, there might be more cases where you, you include entity references, you know, you have the entity reference and then something else in the component that might be an exception. I'm not confident about that, oh, that might be a case. I'm gonna get my tips. Maybe Maybe there's something in here about component design.

We've already mentioned don't give your components methods. One thing you might think about is normalization. Just like a relational database, you might think of basic, first normal form and third normal form. Because Yeah, so second normal form is the rule about the primary key. But that tends to be irrelevant in ECS, because we always have a, an integer ID, basically an entity ID is always just an integer. So that makes it real kind of irrelevant. But then, first normal form is the one about scalar values only, basically. And so that that tends to naturally be covered in in ECS in our ECS. Because as a rule, you can only have individual values, you can't stuff arrays into them. Well, I take that back, you actually can put a fixed array in a component. There, almost always you don't do that, because one of our cars are good. There's number of reasons why you would never want to put a fixed array in your in your component. So, it's not really done, though, we do have dynamic buffers. So you do have components, which are arrays. And so I guess that's what that does violate the rule? I suppose. So. So yeah, you might, just like you do with a relational database, you might want to think in terms of normalization, just to consider what is the what is the data design that avoids all redundancies basically. And you don't necessarily go with that design. But something that's interesting to consider. And then you can start from that view, figure out what that that looks like, and then figure out where to relax the normalization, because it turns out, you know, it'll, it'll be expensive, but it does sort of, in a sense, it sort of represents, like the minimal representation of your debt, because you're not making anything redundant. There's still redundancies. You're in that sense, the the representation is most compact. I don't necessarily have totally coherent thoughts about that. But it's a vague idea I have.

Anne van Ede  42:25  
The thought of using relational database normalization is, makes a lot of sense.

Brian Will  42:32  
Sorry what?

Anne van Ede  42:33  
The thought to use normalization

Brian Will  42:36  
Okay, yeah. Well, yeah, there's an analogy there between ECS and database. I mean, in a sense, it's kind of a database. It's not relational, but it is a database in a sense. Could you state the question again, just general guidelines for components or no?

Anne van Ede  42:59  
Yeah. guidelines for creation of components.

Brian Will  43:02  
Okay, breaking down your component design. As we talked about, like, watch out for redundancies. There's one rule to avoid. When it comes to naming them, start start at least avoiding overly specific names, more general, the names, these are just to see that oh, this thing over here has a position this thing over here also has a position that could just be one thing. So then that's sort of something we covered though. Yeah, I guess that's all my thoughts.

Anne van Ede  43:45  
Okay. For specifically, for components, but you already mentioned the overly specific names. Is there anything else that you need to avoid when designing for components? Specifically components?

Brian Will  44:05  
Just components? Yeah, I don't think anything new. I was thinking about entities is probably getting ahead. But there are cases where it makes sense to sort of like take what would be a really big entity with many components and split it off by you take a single entity and make it two by having like one reference the other or both reference each other through some component. So there are scenarios like that, but that's not really about components, I guess. 

Anne van Ede  44:43  
Okay. My next question is more specific. So unity uses archetypes and there are some advantages and disadvantages to this. You mentioned that for every datatype , you You have a component, that would that also mean that you have a lot of different archetypes, which is bad for unity when it runs its systems? How would you make that trade off?

Brian Will  45:12  
Yeah, you can get to scenarios where you get a big proliferation of archetypes. And there are cases where that creates bottlenecks. So how do you avoid, their archetype proliferation? Well, one thing, one really kind of stupid thing is you can get into scenarios where you have some entity and you build it up individually by adding components. And that's a really silly thing, because it creates all those intermediate archetypes, in many cases totally unnecessarily, you should just directly go from I have this, this archetype, and it goes in one step to this other archetype. That is one thing to watch out for. It's partly, some of our API may be a little lacking, perhaps, and making that convenient in all cases. So that's one issue there. The question is about avoiding archetype proliferation?

Anne van Ede  46:13  
Oh, basically, how would you What do you need to avoid? because unity archetypes, or what is something that you specifically do need to do? Because unity is using archetypes?

Brian Will  46:23  
Okay. You also have to watch out for, archetypes can also be a problem because it leads to basically chunk fragmentation. Yeah, a bunch of bunch of entities, and they'll have foos and bars. But then, in other respects, they're entirely different. So they're not sort of the same chunks. And you don't necessarily get efficient access, then when you loop over all the things with foos and bars, I don't know if we have any solutions to this problem other than to watch out for it. There is a feature that's being worked on, called enabled bits, where the ideas This is one of the problem with with archetypes is the case where you want to like add remove things frequently, particularly tag components. And that's a big problem because of the structural change cost. In some cases, if you're doing a lot of it. And also, it's effectively proliferating archetypes. So the idea of enabled bits is you can just disable individual components. But right now, it's not even clear, it'll ever, it might be just too difficult problem to solve, because it has all sorts of implications for how queries behave. Because the idea is that, Oh, this is a little bit that says this component is disabled on this one entity in this chunk. And so that means it would get skipped by default, and the query would get skipped over that is looking for that component. The query will skip over it. But then the feature is also has an implication of what how many chunks queries will match. And I'm vague on the details, but just just it's been this kind of quagmire of a research project of thinking, can we do this or not? We don't know. And so far, it's it's kind of stuck at the moment. So we don't know if there's this solution, there

Anne van Ede  48:15  
It would be very nice.

Brian Will  48:17  
Maybe it would be very nice. But then there are some hidden costs to it as well as the problem. In particular, in particular, I believe cases where those costs would be paid, even when you're not using the enabled bits, perhaps I think that's like the big sticking point. Like maybe if it would be nice to have some solution to the problem of Oh, I have this particular archetype, but there's one tag that is like being removed and added all the time. But is there a solution where whatever costs that might have is only paid in that case, and not pervasively throughout everything else? Where you're not using the Enable bits at all? That'd be kind of nice. If there was maybe a special case solution, I don't know. This is something that is very much up in the air at the moment. 

Anne van Ede  48:59  
Yeah. Rigth. Um, the next question, I need to ask a question before I can ask the question. Have you had any case where you seen or helped with converting an object oriented code base to an ECS code base? 

Brian Will  49:18  
Uh, no.

Anne van Ede  49:19  
Then we can skip all those questions.

Brian Will  49:22  
Okay, good. 

Anne van Ede  49:22  
That's very fast. You already mentioned naming and then not overly specific names. Are there any other coding or naming conventions within components or systems?

Brian Will  49:39  
Yeah, so the rule we have adopted is we had a discussion about our internal naming conventions for the for our internal you know, for our non internal but our, our various ECS based API's. And what's what we settled on is number one components should not have the word component in them. We are, that's not consistent you look at a bunch of API's and a word component and some of the components of the component names. But the rule that we've established is no, that shouldn't be the case. So eventually, I think those names will be changed. So yeah, number one is just kind of bloat to put component everything. I think we also decided against having tag being the names of tag components. Seen, it turns out to be kind of unnecessary. But then for systems and system groups, we put system at the end and system group at the end. What else in erms on naming. Yeah, that's a big one is just don't don't put component on your component types. It's just it bloats out. It makes everything really verbose. Where in systems you don't refer to systems by name all that frequently. So it's not a big deal. Other than that, this is the standard difficulty in naming, yeah, I don't know if there's any special problems necessarily. Well, there's sometimes a question of how. Yeah, the reason to be to not use overly specific names to to stick to more general names is because then it could be easier to recognize commonalities between various components, that dont necessarily need to be separate components. But it does kind of come at a cost of making it harder sometimes to when you look at code to figure out what is the role of this in this particular game? Like, these are positions, but what are they positions of sometimes it's nice to have more specific names. So there's a tension there, I guess, of sometimes it's a little easier to keep track of your own code and to decide if the names are more specific to your particular problem. Yeah, I don't know if it's a subtle maybe it maybe there's just a tension you have to deal with you. Maybe there's no, no solution for that problem. I don't do any prescriptions. What do we say about naming.

Anne van Ede  52:25  
Fabrice also sent me a document with naming conventions, that is not really enforced.

Brian Will  52:33  
Yeah, it's not really forced, hopefully, before any of this stuff is finalized, stuff be renamed to conform. But yeah. That was the one I was talking about with their conventions. Well, I guess another question is, well, we have various component types like dynamic buffers, and I guess with dynamic buffers, the question is, do you put buffer on the name do you? Do you make it plural? I tend to favor avoiding putting buffur I would just make a plural. If it's a buffer of cats, I would say I would just call it cats, not cat buffer.

Anne van Ede  53:16  
I kind of see that now, In my my head like a cat buffer. Are there any other coding or naming conventions around ECS?

Brian Will  53:30  
coding conventions in this very specific conventions about how to write your foreach loops, just format them I guess, but that's not really interesting. Yeah. I can't think of anything too specific.

Anne van Ede  54:08  
If there's nothing else, that's fine. Thank you don't have to force them

Brian Will  54:11  
Yeah. Okay. Yeah. I can't think of it, nothing springs to mind.

Anne van Ede  54:16  
Okay, um, then we're to the closing questions already, so faster than I thought. Is there anything general around ECS that you've seen people do that went horribly wrong, like some general things to avoid 

Brian Will  54:32  
Horribly wrong? 

Anne van Ede  54:36  
Or less dramatic, but just normal wrong?

Brian Will  54:42  
Well, okay, there is one. What are the common problems we see in our training? Like a really big one is just as I think I mentioned. ECS is not ideal. entities are not an ideal way of representing order data. And so when you want to have a spatial data structure, probably like a 2d or 3d grid, the fact that there's, your entities have no ordered relationships, you can't you can't like, even though not like spatially partitioned things, it's hard to do that with entities. There are some tricks to do it, but those that usually involves, one solution is to use shared components. But the problem is shared components Still, we don't have yet to unmanaged shared components and see that creates lots of obstacles. If you have to use these managed components in your in your code, then then it ends up your code cant be burste, and it's a big problem. So we generally avoid that. So that's like one. One major sticking point is how do you how do you deal with structured data? And one solution is maybe you've, that data that has to be sorry, on spatial data. And one solution is maybe that data shouldn't be in entities and components at all. Maybe that's just in some kind of collection. So that's one big issue. Another big issue is right now, it's not easy in our API to, there are cases where for all x entities, you have a query for all x's and you have a query for all y's, and you want to loop over all X's for all y's. And our API doesn't make that easy. You have to basically basically get a copy of all X's first as separate arrays, copy all those arrays, and then loop over all your y's with a for each, and then you can in the foreach, you can loop over all the x's and or vice versa, you can swap it. So I think convenience, and it has obvious costs of an extra copy, though it's not necessarily as much of a overhead as you might think. Because you're already iterating over all those x's. However many, you know, many times anyway, so another copy isn't basically just one extra read through all the data isn't necessarily a huge deal relative to the work you're already doing. But it feels like our API definitely could make. It's just it's just kind of verbose, having having to do that having to copy all those those entities into separate arrays, and then it's just ugly and kind of annoying. So that's one. Remnd me of the question again, sorry,

Anne van Ede  57:31  
The, something that I need to avoid something that went wrong, what you saw?

Brian Will  57:35  
thanks to avoid? Yeah, those are those are hard problem cases, lets see something to avoid though. But one important question in the context of unity, and it isn't really ECS specific at all. It's just like, how do you communicate with your non ECS code and in our case, monobehaviors, and the general rule we've told people is, you want control to go in one direction, you don't want like your model behaviors to try and control your ECS. And vice versa, you don't want to have both trying to mess with each other. So you want to, you want to establish a strictly one way relationship. And usually we say the ECS should be a control, your systems should be a control. And so your monobehaviors know nothing about ECS, basically, your systems just reach into your monobehaviors and do what they need to do. So you monobehaviours just expose things publicly which your systems can connect us. But then there's the case of you want to do something in your monobehavior that triggers actions in the ECS. And this is getting too far afield from the original question, actually,

Anne van Ede  58:52  
Its actually relevant, for the conversion, so please continue.

Brian Will  58:56  
Okay, well.

So concretely, the the usual places comes up is like, right now we don't have any UI solution in dots, you have to use monobehaviours, basically, if your UI and so we have some, some UI elements, that some that user clicks a button and something's supposed to happen. What you want to have, what you want is the monobehavior to basically create an event entity, an entity representing like, here's something that should happen, and then some system will pick that up, and do whatever, you know, respond in whatever way is appropriate to the existence of this entity, and possibly destroy it when it's done. But the question is, well wait a minute, then the monobehaviors have to know about your, your, it has to know about the world of ECS. And that's what we generally want to avoid. So our solution is that we've come up with fairly recently is, you get them onto you have the monobehavior create an ECB record the creation of the entity to the ECB and then some system will come along every frame and look at the monobehaviour and say, Hey, do you have an ECB for me? If so, I'm going to take that and play it back. And that's how you get the communication between monobehavior land and ECS. And by making an ECB instead of using entity manager is that way, the mana behavior doesn't have to know what world even you're talking about. It doesn't have to know anything about really what's going on ECS, it does have to know about the existence of ECB. So it has to create an ECB. But other than that, it doesn't have to know anything about ECS at all. So ECS, in that sense, is entirely the, your systems are entirely control in that in that scenario. So yeah, that's a problem. Yeah, good.

Anne van Ede  1:00:44  
Yeah, no, this, this is relevant for like a code conversion. If you have like a split, like you have converted half your code and not the other half, then you have also a case where you have monobehavior and system that need to communicate. So that's why Yeah, why I'm interested in this. But should you be able to work that, like the bit flip case that you talked about earlier that you haven't quite yet yet working? If you have a an entity that basically lives alongside your event system, in this case, your UI, and you have like an entity UI, and then the UI can add or remove specific components that correspond with UI events. Like every button has a different component. And with a bit flip, you can turn it on and off. And then the system knows that that button was clicked because the component exists. Would that be also possible?

Brian Will  1:01:47  
I would say I mean, yeah, you could do that. But then, then the, I would say at that point, the monobehavior side is knowing too much about the ECS data.

Anne van Ede  1:01:58  
Yeah, or, or through like, like the ECB. But instead of creating an entity, you create a component.

Brian Will  1:02:05  
Yeah, but then it has to know about entities. And the question is, what entity is it affecting? And where does it get that? Like, who's, I guess you're gonna have a system come along and plug, pass an entity to the monobehaviors, and monobehavior itself, just expects to be told what entity it needs to manipulate? I guess that's okay. Um, that's always a problem. The ECB not having to, sorry the monobehaviour not having to assume what world that needs to interact with I guess. Maybe it's not so bad. I don't know, I usually I would just my thinking was just oh, you should just stick to creating entities, basically, that's probably all the monobehaviours should do is just create event entities. And then you just read the system code to trigger whatever changes to be affected from that. That seems like the cleanest way to do it, where the monobehaviours know the least about what's going on in ECS. I don't know I'm not, I'm not super confident if the scenario laid out is actually all that much of a problem. So I don't have to see it. Obviously, you haven't done much. In our training. We haven't done much integration with monobehaviours beyond just basic UI. Like one thing we haven't done yet is I've not seen done is integration with audio monobehaviours, because right now, we don't have our dots API for audio is not really ready for use at all. So that'd be one area that people might run into right now. Well, we want to put audio in our game, and we need monobehaviors for that. So how do you get the like, like imagine you have a positional audio, you know, some some audio sources moving, right? And you need that game object to have its position updated. So what happens there is a system know about what monobehaviors need to be updated, and it does the work of updating their positions? I don't know. Okay, maybe I maybe I don't have I don't necessarily have well proven opinions on what the problem what the solution is, here.

Anne van Ede  1:04:22  
That's okay.

Brian Will  1:04:27  
I feel like I'm rambling more at this point for some of these questions.

Anne van Ede  1:04:33  
That's, that's perfectly okay. It's like I said, it's not the question necessarily, that I need answered is the information that I'm going to pull from your brain. And the questions are just a means to an end, basically. So as a last question, is there anything that you consider important around ECS that I haven't asked about?

Brian Will  1:04:55  
See, in practice, a lot of the difficulties people run into in our training aren't about ECS, per se, as I sort of was getting into a lot of our difficulties stem from when they do want to use collections and not use entities, primarily for the for solving spatial problems as I described. But then also people run into problems with dots with the job system, just figuring out how to work around potential conflicts within their jobs. And you know, how to resolve how to make the job system happy that you can schedule different jobs and have them all not conflict with each other. So a lot of our training ends up focusing on those kinds of obstacles. The actual the data design issues in the ECS issues, the ECS spot self issues, those tend to get worked out prettier in our week in the in the first couple of days, usually. And then the rest of the week, when people are struggling. That's like there's so there's so many things in the API, like dealing with ECBs. That is a big struggle point. I guess that's the answer. The question is everything about structural changes, and minimizing structural changes is a is a really, it's a really big sticking point. It's one of the more difficult areas of working with ECS right now. Partly it is just a convenience thing. We're working on a few ideas about how we might make it more convenient in your systems to use in your foreaches, just use ECBs, particularly for the case where like you go back and forth between making a foreach either run on the main thread or scheduled as a job or parallel job. And right out with ECBs, you have to we have a parallel writer for the case of parallel job. And it's annoying to have to swap back and forth. But we have some ideas about how to basically make that transparent. So you don't have to manually update every individual method call on your ECB when you switch between single threaded and parallel. But then, the jobs really do complicate the picture, because you have to think about when are these changes actually taking place? Because that's gonna affect things like your queries. And it's just just strategize, strategizing about trying to consolidate your structural changes into putting them in one part of your frame or as few parts of your frame as possible, instead of spreading them throughout the frame. That's a really big issue, it's something you really have to be careful about, because because if you spread them throughout the frame, then but when you when you do structural changes, it triggers the syncpoint that means a lot of jobs that might be in flight have to be completed. In some cases, all done. So the that's that's a really big concern. I don't know if I have strong answers about how to deal with those issues other than it's a it's a, it's certainly a usability issue. Let's put it that way. Yeah, it was one of these things that can trip people up if they're expecting to just be able to use basic, learn the basics and just jobify their foreaches. And everything will necessarily perform great. It's not necessarily the case. There are unfortunately, a lot of ways in which the dots if you get some things wrong, like your performance gains, aren't that that great, or maybe not as great as you were expecting. Yeah, so so maybe that's, that's the, the usability issue is not just it should be easier. Well, oh, oh, here's a big thing. Again, I'm still sort of rambling mode still, but here's something that's important. What I would like to be possible is to make it really easy to take your systems and reorder them. And also to play around with what very easily toggling whether the foreach, whether the the foreaches in a job horse schedule is, that sorry, whether the foreaches in the system are scheduled as jobs or single threaded, it's really easy to play around with moving things around so that you can optimize that way. Yeah, the fewer obstacles you have to moving things around in terms of system ordering and ordering of your jobs within the system, and what's jobed and what's not. The better for users to be a lot easier to optimize, if you can sort of play like Tetris of this moving these things around and finding a way of making them fit better. Because, yeah, when you really want to optimize, you open up the profiler, and you're, you're trying to play this game where you maximize utilization of the cores. And that often, there are cases where it depends on the ordering and configuring out the optimal way to to order things and so be, it'd be great if we could make it easier to play around with order. Oh, and one last thought is, it'd be great to have one one part of that is right now the the system's window we have for debugging isn't the best because well, one basic issue is, when you're not in play mode, you don't even see what the system order is. And that can be really annoying. So hopefully, there's some solution to this problem. My thought was just maybe, maybe when you exit play mode, it should just still show you what the systems were, even though the game is not playing like that, that would be helpful, something very simple like that. There are various thoughts about that problem. But that's one thing that really bugs me.

Anne van Ede  1:11:13  
It also took me a while to realize that it was actually that that was the order in which the systems were, you know, handled. Because it's nowhere it's like, not online, but not in the debug tool itself. It's not nowhere specifically stated that that's the order that you see there is like the actual order that you use, I figured it out when I in the code, I swapped two systems around, and then I found them different in a different order. And, oh, does this correspond to the order that I, hold on a second? And I started checking it like, Oh, yeah, this is before this. And then this is before that, okay. Now this makes sense. And then I knew, oh, wait, wait, this is the actual order in which it's, it's performed. There's a lot of implicit data in all of ECS, jobs, bursts and stuff that if you once you figure it out, it's really useful. But it's really difficult to figure it out. Because it's stated, like, nowhere, it's concretely stated. What is, you know, all the information that's actually available.

Brian Will  1:12:20  
Yeah, I know, the entity debugger window, which has been deprecated. It has that whole chunk utilization view. And I could never figure out what those numbers what that little graph is supposed to mean. It's very hard to figure out. Yeah, so that's getting improved. Significantly, it's being worked on heavily. But it's, it's not where it needs to be. And also just thinking about toggling systems on and off. And I would like to be able to just like in the editor, put not not a debug break, basically a breakpoint, basically. And in unity marker on a system of Hey, when you reach the system, I want you to pause, not not have a actual debug breakpoint, but pause so that in the editor, I can use the inspector, this is a problem with debugging right now is that if you actually do proper step debugging, in like write or, whatever, when it hits a debug breakpoint, you can't go into the editor and look at the inspector, which is very often what you want to do and see what is the state of my my entities and my component data. And you can't do that. So I would like to be able to pause on an individual system. And so a related related problem is just it's very, I think the tricycle up a lot is because the systems don't update when there's only matching the query, you get into debug scenarios where you're trying to figure out why your code isn't working is because oh, like you thought you had something matching that query, but you don't. And so the system is not being updated at all. And the system window isn't always great at it. It shows you when the system is inactive, but like it's not clear, I would want to be able to look at my code and my systems in a system window and just see, has the system ever run at all ever? Like that'd be really useful, like not as it running now. But Has it ever run ever? And that there are a lot of scenarios where that would answer my question of Is there anything matching this queries? Like, is this code doing? What I think is doing at all? Or is there something even really basic I forgotten?

Anne van Ede  1:14:26  
The usual debug mode for me was if it shows like a negative running time, then there's something wrong with my system. Yeah, either minus like 0.5, usually around that value, or 100 milliseconds, then sometimes it flips between those, like on and off, like minus 100 minus 100 minus 100. And then you know that there's something wrong with my systems. So that's how I debugged my systems like it has a insane value. Something I made a mistake.

Brian Will  1:15:02  
Was this in the old entity debugger or?

Anne van Ede  1:15:04  
I didn't know the the entity debugger was deprecated. I haven't actually used ECS in a couple months now. Okay. I might have been an older, it's officially

Brian Will  1:15:12  
been deprecated for a long time, because the person who made that thing, I think left the company like over a year ago. So, yeah, so for long, for quite a while, you're officially supposed to using the entities and systems window, the new dots editor package stuff, which by the way, will be moved into the entities package itself eventually, so it'll be a single package, because it also will be nice. But yeah, you're supposed to be using that stuff. I mean, part of the reason the product problem is that those things don't have feature parity with entity debugger. That's one reason why the entity debuggers hung around so long is because it has had stuff that still occasionally is needed, even though it tends to be broken half the time.Yeah. 

Anne van Ede  1:15:50  
It could be the company I was at was using like a fixed version, like it's updated only once a while. So if the probably had an older, older version of ECS still, and then also the debugger and stuff.

Brian Will  1:16:06  
Yeah, well, it's still there. Like it's still this part of the editor. So well not the editor is part, I guess, it's part of the entities package, I guess. Yeah, it's still there.

Anne van Ede  1:16:17  
It's good to know that there's something new,

Brian Will  1:16:19  
but I think it'll be removed pretty soon. I think, we'll see. But you saw it go from like, you've seen negative numbers? Yeah. What did that what does that mean?

Anne van Ede  1:16:31  
Sometimes it meant that you usually had to do with native structures, that you made a mistake somewhere there that you either write to a native structure that you're not supposed to write to. Or I thought it was something like that. I don't really remember. It's been a while.

Brian Will  1:16:55  
Probably some bug, it doesn't sound like correct behavior. So

Anne van Ede  1:16:58  
It was very useful that, okay, at least, I mean, if it if it hadn't gone to negative numbers, there was no other debug method. Like there was no other. That was the only feedback that you done that specifically thing wrong. So I remember being very happy with negative numbers, but I thought I messed something up. And yes, I did indeed mess it up. It shows.

Brian Will  1:17:20  
I don't even know what that millisecond numbers really supposed to indicate. I don't know if it's supposed to indicate like, how many is it? I assume it's an average over the last number of frames, but I don't know how many frames and so it doesn't. I mean, you probably shouldn't rely on it. But I don't know how useful it is other than just like, Hey, is this thing running at all right now?

Anne van Ede  1:17:37  
Well, it's actually quite useful. It's also quite stable. I suppose when you run a different times. It's quite stable. I used it to, to tell me within a margin, of course, if the optimization that I performed was actually useful. So and when you see that you only use half the time, consistently use half the time, then it tells you Okay, what I did wasn't useful. It's I guess it was effective for some things. Yes. especially

Brian Will  1:18:07  
We recommend people not rely on we've recommended us to break out the real profiler, though. Yeah, it's you can be listening to that. I know. So

Anne van Ede  1:18:16  
When I found the not the profiler, but the profile analyzer. Yeah, yeah. That one since then, I used that one.

Brian Will  1:18:30  
Yeah, that's, that's useful for comparisons in particular, I think it also is that yeah, it also has a search feature. Yes, can be very useful. Yeah. Unfortunately, the regular profiler doesn't have that which can be frustrating.

Anne van Ede  1:18:42  
And also the, the, or maybe I just missed it. But in profile, you can only select one frame. But in profit analyzer, you can select like a range. And that's really useful for comparison. Basically, what I

Brian Will  1:18:57  
I haven't done that, but yeah,

Anne van Ede  1:19:01  
we had a we, I used it for I a crowd simulation. And then there was a time when they were still generating characters. And then there was at some point, they were finished generating characters, and it was just running the characters. So I could stop the, like 400 frames or something it could fit in, and then I would stop it around the time that like, the first half was still generating and the second half was just running. And then you could select different parts of it and compare it to like the running to running in the generating to the generating that's really useful. It was right. I was very, very happy with that. This is the one thing I was really missing a unity, so.

Brian Will  1:19:45  
Yeah, that's an interesting point because in our training the students pick, I dont know if you're familiar with their training process, have you seen the link to the training samples repo Like, you know, it's public repo that like they're in zoom. So they, the students split up into groups, usually a four people. And they pick one of these samples is interesting because some of them basically instantly, you know, they settle very instantly, very quickly into, like their the peak scale, you know, the the, the the normal performance, but then others their performance throughout the simulation, it can vary greatly, because the workload is changing a lot like that, on that page, the auto farmers, for example, kind of a problem with it is that it starts out with these farm, the farmers spawn each other, like they gather resources, plant crops, and they spawn more and more. So the problem is you don't have a scale problem, you know, it's it's too small scale to start, and you have to wait a long time to get it to scale up and see where your real bottlenecks are. So it's interesting problem of maybe it'd be great if I would really love if we eventually get to the point where we make it easy to serialize states for debugging purposes. So you can just very easily, I dont know, hit f5, or whatever to save, save a snapshot, and then you can just reload your debugger and get back to the state you were working in and trying to test. So I mean, hopefully, eventually in dots we get that that sort of thing becomes I mean, wouldn't be totally transparent to the user, there'd be a lot of cases where the user would have put in the work to make sure the serialization works. But potentially, there's a lot of things you could do with with ECS serialization that be very useful for debugging in a way that be very hard to do with conventional, you know, with classic unity. So there are a lot of cool things you could do with debugging that is what I'm saying. is unfortunately, like, not much of that in place that yet though. well.

Anne van Ede  1:22:14  
That was basically it for my questions.

Brian Will  1:22:17  
Okay, great. I feel like I, about halfway through, I started losing my ability to speak properly. Tends to happen if I speak too long.

Anne van Ede  1:22:29  
That's okay. It's like 20 past eight here now. So it's evening for me.

Brian Will  1:22:38  
I dont have an excuse. I still not even

Anne van Ede  1:22:40  
My brain is turning down.

Brian Will  1:22:42  
Yeah.

Anne van Ede  1:22:46  
So, um, actually, I thought it was very funny that you mentioned the database normalization rules, because that's actually the basis of my my research. The first idea that I got to do this, because right now, I want to focus mostly on designing components. Because the company I'm at right now has like a software that training software for a policeman and workers and stuff. So they have like, huge amount of different right now, objects and monobehaviors and different people, they can place into a simulation. So it's going to be a huge amount of work to convert them. So that's why I wanted to do the conversion tool to help them convert all their data in different objects to entities and components. But for that, I want to make like a cross section between base classes and child classes to see how those components are split, and also how they're used in systems. But in your case, you say, just put everything aside and split everything up. So that's why I'm still talking to different people, because some people say don't split it up too much, and other people say everything up. But this also, I noticed depends a lot on what implementation they use. Archetypes usually say split everything up. The guy that said don't split everything up is, uses sparse sets. And this is completely different. As far as sets has too many components, it becomes slow.

Brian Will  1:24:26  
I am not really familiar with the details of any other implementation, like the actual storage.

Anne van Ede  1:24:34  
It's really funny to see all these different, like basic rules for different people and different implementations and everything, but the database normalization is the basis for my for my research. That's pretty funny.

Brian Will  1:24:49  
Okay, oh, yeah. So I mean, what when you do normalisation, so, as far as I can tell, like basically, what, what normal form rules are you applying?

Anne van Ede  1:25:02  
Oh, numbers? Um, I think up to third?

Brian Will  1:25:08  
Yeah, that's usual. Three and a half

Anne van Ede  1:25:12  
Boyce-Cod normal form, BCNF.

Brian Will  1:25:17  
Yeah, right, right. I think wats most will do anyway, in practice.

Anne van Ede  1:25:23  
For me, the most important one is the that it can be like a sparse matrix, it has to be every field has to be filled. And basically, 

Brian Will  1:25:33  
Fill the holes basically?

Anne van Ede  1:25:34  
Yes, every database, every data component in a component needs to be used in every system that the component is used in. That's basically how it I formed it in my mind. So if it's not sparse, it means that all the data in a component is used, which means that the component is used optimally. And that in some cases is important. Because in sparse sets, you can't have too many components. So you want to merge as much as possible, but only if the whole component is used in the systems. So that's where the database normalization for me comes in. So I can figure out when a component is not sparse. That's basically the thought process. And if a component is not sparse, it's optimally used in cash. Thus, that's the component you want. 

Brian Will  1:26:26  
I'm, I don't know if I have this correct. But my understanding that third normal form, let's say in my notes here, I said, so like, the idea is that this is what I wrote, the information entities should be about only that entity. If I had these have different archetypes have the same repeating groups of component values, it's a sign you're violating third normal form. The solution is to split such groups of entities off into their own entities, which can be referenced from the original. So for example, if my favorite book is Moby Dick, then an entity representing me should not include title Moby Dick author Herman Melville published year 1851, decimal number, the Decimal number 813 point three. Instead, the entity representing me should reference the second entity representing the book. And the second entity would have all that information. And short think hard about when it's logical to split up entities, because looking up entities by reference is fairly expensive. It's common to violate the third normal form at the cost of storing some information redundantly. That's what I wrote I wrote this months ago. I don't know how correct that is. But

Anne van Ede  1:27:33  
It sounds pretty correct, I just, the data is slightly different as in you are talking about entities and splitting entities up. Yeah, I took about component as in a component about, for example, position shouldn't have its velocity in it, because it's not saying something about the position. That's the way I interpreted

Brian Will  1:27:54  
yeah, that's the same way. I guess it applies to both, though, you, this is a hard call, because following entity references is expensive, you know, relative to just linear memory access of going through component arrays. It's expensive. And so you some, I think in practice, there are cases arise, we just have to think hard about your particular problem. And what's as Mike would emphasize, what is the common case? Like? That's what you have to think about first and foremost is, and that's how you make your decision. That's what needs to be fast when what am I doing most often? And that's how I make those calls basically. Yeah. So I'm just kind of curious. So basically, you have Have you written any code yet? Or is this still a planning phase this, or?

Anne van Ede  1:28:51  
no, I'm, I'm writing code. I'm almost finished with getting, well, I'm like iterating. But I'm last Friday, I got my first component design out of it. Only it wasn't correct yet. But no I got I use a syntax of semantic analysis in Visual Studios from their compiler API, to get all the data I need and the connections between data and stuff that I need. And then I'm combining the data and generate a good component.

Brian Will  1:29:32  
What do you mainly reading from Are you mainly just looking at the class fields and struct fields or you're also looking at methods at all, are the methods relevant?

Anne van Ede  1:29:40  
Well, they're relevant. But in my current iteration, not yet. They are in the iteration next, I want to because I, currently I'm writing my tool for unity and because the company is using unity, but I don't want it to be only for unity. So I want to be able to plug in, because I didn't know you're the first person that actually said that burst might be able to optimize it better if you have one data value per component. So I didn't take that into consideration. But I want to plug in like a profile that says, okay, you use unity, unity uses archetypes this and this and this you shouldn't do and only use one data per component, because, Burst. But because that's not the only thing I want to be able to serve, as sparse sets wants to combine data into larger components. I want to look at, like this base class has this data, this child class has extra data, which means that there's no component that has a little data of the parent and little date of the child, because then the parent would have redundant data of the child that is not using, that's the one end. And on the other hand, I want to look at what methods is using that data, and basically what the systems would use. And then if there's data in the component that I've designed up until that point, and the system only uses half of that data, then that then the component should be split. So it is relevant, but it's one iteration too far for me right now. Like next week, hopefully?

Brian Will  1:31:19  
Well, you say, it sounds like the design considerations for sparse ECS might be very different. So have you considered just having different solutions for archetypes and sparse ECS? What was it called sparse 

Anne van Ede  1:31:35  
Sparse sets, it's basically there's one array that has contiguous components, but not every entity has that component. It doesn't care, it just clumps everything together. And then there's one array that is sparse. And it basically says for every entity if it has that component or not. And that's basically a bit flip. So the actual data is stored contiguously, but the index in whether or not, you use that component as an entity that is sparse.

Brian Will  1:32:08  
So if I've an entity with A and B and another entity with just A, in this one big array. For every entity, everything has an A and a B, even though some some don't have B's.

Anne van Ede  1:32:24  
Now the other way around the the same as archetypes, you have an array with all the A's and all the an array with all the B's,

Brian Will  1:32:34  
okay, so it's okay.

Anne van Ede  1:32:35  
If there's two A's and one B in an array, and there's a separate array of bits, basically. And it says, okay, entity one has  A and B, entity two has only B. So if there's there's one array with all the data of A and one array that is larger, because it also contains the entities that do not have an A component. And it just has a bit flipped, like entity zero has A, entity One has also A but in the case of B, entity, one has B, entity two does not have B but it's still in the array, but not in a data array. Like there's this split between contiguous component data and a separate sparse array of Do I have this entity or not? And where is it stored?

Brian Will  1:33:28  
So are the data arrays then all the same length? Or are they different lengths? 

Anne van Ede  1:33:35  
They're different lengths?

Brian Will  1:33:37  
Okay? Because it's not it's not storing a gap of just, oh, here's a B that's not used by anything. It's just it's not reserving a spot for on

Anne van Ede  1:33:44  
No, that's what the big flip arrays for, Yes.

Brian Will  1:33:50  
But then when I go, if I want to do a query and say, give me all the entities that have, everything has an A and a B, what does that look like?

Anne van Ede  1:33:59  
Archetypes is better at running through systems. Indeed. It's better in I think, in sparse sets, it has to run through every bit flip array to figure out, okay, which entities correspond to it. I think the one thing that is easier, is adding or removing components, because it's just two additions, one to the component array and one to the bit flip array. Basically. That's just that's it.

Brian Will  1:34:32  
Say I have five I have five foo components. There are five entities with the foo and I remove what the the one in the middle needs to be removed. What happens?

Anne van Ede  1:34:44  
Oh, that's a good question. I don't know. I think that also depends on the implementation itself. I think the one I spoke to was ENTT and I think it just remove the last one in the array and plumped it the middle and then just change the reference in the bit flip array.

Brian Will  1:35:04  
Okay, that makes sense.

Anne van Ede  1:35:06  
Because it doesn't care about order.

Brian Will  1:35:09  
Right? Oh, okay. Oh, well, then you're going through? How do you even do a query that says, I want all the entities that have As?

Anne van Ede  1:35:25  
There, you go through the bit flip array. And for every on bit, you know that there's an A component, and you have to

Brian Will  1:35:32  
scan through for every query to scan through all the entities,

Anne van Ede  1:35:36  
yes. But because it's only a bit flip. It's very, like very small, where, but yeah, that's the downside of sparse sets.

Brian Will  1:35:45  
If you have many entities that gets nuts, though, like have a million millions of entities have to scan all millions of entities to find the one that has a single one that has a foo about it.

Anne van Ede  1:35:55  
And that's also why it's convenient to have large components. Because if you have to do that for 10 components with just one data type, then you have to do that 10 times. But if you have just one component with all 10 data types in it, that's a lot more convenient.

Brian Will  1:36:10  
Yeah. Oh, sounds like a lot of downsides.

Anne van Ede  1:36:18  
Actually, it's not that bad. It's a I can, the guy who wrote that, a specific library also has a couple of posts on the differences between archetypes, sparse sets. And another one big array, which is basically a stupid version of sparse sets, with more downside.

Brian Will  1:36:39  
Is that where you have bigger component array, and there are gaps of like, Oh, this isn't used at all, but is still there?

Anne van Ede  1:36:43  
Yes, that is just this stupid version? Okay, as sparse sets is smarter than big array.

Brian Will  1:36:50  
Straighten up memory, but Well, you're not getting the advantages of reading linear memory access, are you?

Anne van Ede  1:36:59  
Well, it's only when you figure out I want. Actually, what I've said just now is not entirely true. When you want to get or when you want to get all entities with a certain component, then you have a downside. But if you just want to get the components as in I want to run over all positions, then you don't have to bother with a bit flip array at all. Sure, I can just run over the normal array. Only then I want to find

Brian Will  1:37:31  
but then the problem is I'm a common thing you do in with archetypes is everything that has an A to B. And you couldn't just run to the A's and the B's. Because you wouldn't know which correspond to which, like, there's no correspondence of index, I of the As index, I of the Bs, there is no correspondence, right?

Anne van Ede  1:37:49  
I don't know if there's like an like the components have an index of their entity. I don't know that. If they would have an index of the entity, you can just run over all A's, and then check for the Bs. If the B has the same index, then then you would take

Brian Will  1:38:06  
Right. That can be very expensive, though. Interesting.

Anne van Ede  1:38:14  
But like I said,

Brian Will  1:38:18  
Yeah, yeah, that could be expensive, very expensive.

Anne van Ede  1:38:21  
The upside is because adding or removing components is so fast, you can use like an event system. So if you do press a button, this case for UI, you can just put a component. Okay, I press the move button, I add a components to my player, move ahead this much. And then a system just picks it up and runs with it and removes the component once it's done. So there's very, that's a very big advantage. Because you can use an event type system much more easily than in unity and in unity that's expensive if you want to add and remove components often.

Brian Will  1:39:02  
Yeah, but if it's a UI system reacting to user interactions, like how many events are we talking about anyway? It sounds like it's really small scale.

Anne van Ede  1:39:10  
Yeah, I just used a UI as a as an example. But he used it for everything. bombs, exploding characters. damage or something and, like, for everything.

Brian Will  1:39:27  
Yeah. Okay. Yeah, if it's if it's not if there are events triggered by things other than user then yeah. Interesting. I do recall someone on our team briefly mentioning that, yeah, the they had considered, I guess they consider what support sets I guess one was thinking about just exploring that was an option. But it didn't really go anywhere. Maybe I should talk to them more about it. You're saying e t t, e n t t. That one is is the one yes. Okay. Got it. Cool. So I've heard of it.

Anne van Ede  1:40:03  
But I'm sure if I can find it right here. His blogs are very difficult to find. It's insane. He has. See if I can find it for you because I know the click

Brian Will  1:40:23  
Skypjack?

Anne van Ede  1:40:24  
yeah. Then you have to go. No, not this one. It's this one. No, not that one either. Yes, this one. Right, I could send you this link. You get immediately to his blogs. And you can it's ECS back and forth is basically where he explains from the bottom up first with ECS, but also how he implemented this in sparse sets, and how he compares it to big array and archetypes. 

Brian Will  1:41:14  
Okay, I'll have to read it.

Anne van Ede  1:41:20  
wait for the new one. Referencing that one. Oh,

Brian Will  1:41:25  
I must have clicked the wrong one. Okay, yeah, this makes more sense. So I clicked the last one. I actually found it just by searching for ENTT blog. So it wasn't hard for me to Google it.

Anne van Ede  1:41:35  
The problem is, you have this welcome page. Click on any link up top, you cannot get back to it. Like there's or you may have changed something but I I searched everywhere you cannot find his blog in any of the tabs above. Like you can do tags. And then you can sort of find them through there. But there was no, like, menu option to go to his blogs. Except for now, I now I figured out like a month too late, that if you click on top left

Brian Will  1:41:36  
His face? If you click his face you go to the home page.

Anne van Ede  1:42:15  
Yeah, only the homepage you can find this blogs. So that's where I was like, Okay, I'm on his website, and now, where do I go, how do I get get and then I clicked somewhere and I couldn't get back to this page. So that's a bit weird. But yeah. It's a good post. Right. So um, I actually got some small questions left. Would you like to be kept up to date about my research?

Brian Will  1:42:51  
Sure. Sure.

Anne van Ede  1:42:54  
With the possibility of getting me paper at the end?

Brian Will  1:42:58  
Right, sure. Would you just email it to me or on Skype, I've set, no slack is fine.

Anne van Ede  1:43:07  
I don't know yet. Maybe. Hooks into my next question. I'll send something on LinkedIn. Can I add you on LinkedIn?

Brian Will  1:43:17  
Oh, sure. I hardly used to think then though. Like, I look up a resume out there. That's sure.

Anne van Ede  1:43:23  
Networking phonebook like,

Brian Will  1:43:26  
yeah, I've told I just pointed the, sure.

Anne van Ede  1:43:32  
Right. And then my last question, are there any people you think I should talk to? 

Brian Will  1:43:37  
Oh, talked to Fabrice already? The real experts to talk to if they have time they're very busy at the time this moment would be Mike Acton and Andreas might have more time Andreas Fredrickson

Anne van Ede  1:43:55  
I haven't heard that name yet. I think, could you maybe me her

Brian Will  1:44:09  
His name is Oh yeah.

Anne van Ede  1:44:15  
Oh whoops, I somehow heard Andrea instead of Andreas.

Brian Will  1:44:20  
No Andreas. Yeah.

Anne van Ede  1:44:20  
On Slack then I can stalk him myself.

Brian Will  1:44:27  
You know if you Mike is actually very generous with his time but the problem is he just had a kid he has a new baby so very very busy. Yeah. So but yeah, he will definitely be like the source to talk to. But Andreas might be available. I dont know, I should ask around. Who else is really the real in house expert, cause I realize on a lot of us work. No doubt. I mean, a lot of people working on dots are kind of honed in on their particular thing of like, Oh, we work on collections of mathematics and then the implementation but don't necessarily use it. So in a sense Fabrice and I are kind of the ones most often using it of late. But then we're not certainly the most expert on on, we don't have long term expertise on ECS. Well, I don't know, actually, I don't know if Andreas. He's certainly an expert programmer. Like he's one of our top expert, or best programmers, so that's on the dots team. So that's why I had in mind, and he was with he was at Insomniac with Mike for a while. So that's why his name sprung to mind. I might think of another name, but that's mainly it.

Anne van Ede  1:45:57  
Okay, if you do think of something, please let me know. 

Brian Will  1:46:00  
Sure. 

Anne van Ede  1:46:04  
I think that's it for me, then. Do you have any questions for me?

Brian Will  1:46:09  
Um, no, I think, no, no, I think we've covered a lot. But But thanks for reaching out. And I hope this goes well. Intereseted to see what kind of results you get. Is it possible that you just another way, I was prescribing that, and maybe some other people was like, Oh, you just split all your components up into individual, single field components? Does that make it kind of trivial? Like do you just basically go through classes and structs? Is every field is a component? Or is there some?

Anne van Ede  1:46:46  
Yes and no. As in, if you split everything up it? It's easier. But the one thing that I still need to do is make sure that if every thing that has a position, that it knows that everything is the same position, as you said that you don't have redundant components. I link those together, like, oh, everything, this all uses a component. position. Okay, that's just one component, because it's the same thing.

Brian Will  1:47:20  
And how can you recognize that other than, oh, these are the same? They like inherit from the same level, but the same interface or something? Like what would

Anne van Ede  1:47:27  
Yeah, or do you have the same? or similar, same or similar name and same data type?

Brian Will  1:47:34  
Yeah, right. Okay. 

Anne van Ede  1:47:37  
That's still broken, that's the one thing that I can 

Brian Will  1:47:40  
Well, that's tricky. Because cannot kind of guess, like, you can't have you can't give definitive answers. In many cases. You just have to like, I dnot know, put a little flag on, hey, this might be wrong. Yeah, exactly.

Anne van Ede  1:47:52  
And that's why it's only generates a plan and not the conversion, because it needs user input. Because otherwise, yes, this won't be

Brian Will  1:47:58  
Yeah, when you first messaged me, I initially read said, Oh, that's I'm not sure about that doesn't seem very plausible. But if it's just a recommendation plan, that's way more plausible.

Anne van Ede  1:48:07  
Yeah. And also, I want to work on the visualization. So it's easily visible, which previous objects are now structured as entities and how they're structured as entities and how they like, relate to the other entities. So you have visual, very visual, okay, this all uses position or something less often used as position, maybe an AI component, these all use an AI components. Okay, sort on all my AI components. Okay, but I'm still missing one of my AI components. What happened to that one? So you can also check but I it depends on on how much time I'll have how far I'll get with that.

Brian Will  1:48:55  
You have a deadline?

Anne van Ede  1:48:57  
I need to graduate. So June, July, somewhere.

Brian Will  1:49:02  
Oh, that's. Well, sounds like you have some work to do them. But I hope this was helpful.

Anne van Ede  1:49:09  
Yeah, thank you.

Brian Will  1:49:10  
How many people are you talking to?

Anne van Ede  1:49:12  
I'm hoping to, you know, I'll probably go crazy if I go over 15. So I know I've got eight or nine people I've talked to with you. Okay, eight or nine. So, yeah. 

Brian Will  1:49:29  
From aside from unity, who else have you reached out to?

Anne van Ede  1:49:35  
I've talked to see I've got a whole bunch of people. I've talked to three to four people who created their own ECS implementation outside so ENNT, ECST, Entityx I'm speaking to Wednesday. And then I've talked to one person who has already published a book on data oriented design, Richard Fabian, and to one who is going to publish a book on data oriented programming, which is slightly different in his opinion. I'm not entirely sure.

Brian Will  1:50:21  
It's confusing.

Anne van Ede  1:50:23  
Yeah, and then to Steve McGreal from Bruce and you from unity. The only three from unity. Quite a few different views on the topic, which is really nice.

Brian Will  1:50:42  
I'd be if you can compile that That in itself would be interesting to see the various ideas compiled. Yes. So maybe that's in your paper? I don't know.

Anne van Ede  1:50:52  
I was planning on doing that, too. That would be really helpful on so many levels. Like there's so much information on the internet, but no, like, comparison, or overview of what is not everyone says that it's because of their platform that they use specific rules. And maybe they don't know because they don't have the overview of what other platforms use. They kind of preach their own truth. But if you can say okay, these and these are general that these and these rules are platform specific. That would be really helpful for people learning it then Okay, there's all these different opinions, but I'm using this platform so maybe this is what I should be doing.

Brian Will  1:51:32  
Yeah, that's a problem. Yeah, that definitely happens like I was surprised during a unity like there are very few people here who know much at all in detail about like, unreal or Godot like other game engines, you know, the off the shelf engines so it's a little funny that people are so kind of tunneled tunnelled on their own their own thing that they don't pay attention to other stuff out there that that happens for sure.

Anne van Ede  1:51:55  
Wait, what was the other one, unreal and?

Brian Will  1:51:58  
Godot. G O DO T. 

Anne van Ede  1:52:01  
Oh, right. Yes. I think I, I am going to write it down anyway.

Brian Will  1:52:05  
It's the open source one. I don't think they're even dabbling with ECS. They might have considered?

Anne van Ede  1:52:12  
I don't know. I can always check

Brian Will  1:52:15  
I dont know if unreal is doint anything in this area?

Anne van Ede  1:52:20  
I know. There was this one talk at unreal fest from a company Funcom, and they used they said they used unreal ECS. Like they didn't call it ECS, but ECS. They called it, like, FDL, or something.

Brian Will  1:52:42  
They made their own?

Anne van Ede  1:52:43  
Yeah. Okay. I don't know if it's funcom or if it was unreal. So I don't know if it's like, where it came from. I haven't been able to talk to him yet, sir. 

Brian Will  1:52:53  
Okay. Okay. Well, it's getting late for you. I used to go eat before another meeting. So actually cut off too, but 

Anne van Ede  1:53:04  
Thanks a lot for your time.

Brian Will  1:53:05  
And sure, and good luck and I'd be interested to see the results. So let me know. Sure. Okay, thanks a lot.

Anne van Ede  1:53:12  
Bye 

Brian Will  1:53:14  
Bye.

Transcribed by https://otter.ai
